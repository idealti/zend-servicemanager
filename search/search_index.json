{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-servicemanager Master: Develop: The Service Locator design pattern is implemented by the Zend\\ServiceManager component. The Service Locator is a service/object locator, tasked with retrieving other objects. File issues at https://github.com/zendframework/zend-servicemanager/issues Online documentation Documentation source files Benchmarks We provide scripts for benchmarking zend-servicemanager using the PHPBench framework; these can be found in the benchmarks/ directory. To execute the benchmarks you can run the following command: $ vendor/bin/phpbench run --report=aggregate","title":"zend-servicemanager"},{"location":"#zend-servicemanager","text":"Master: Develop: The Service Locator design pattern is implemented by the Zend\\ServiceManager component. The Service Locator is a service/object locator, tasked with retrieving other objects. File issues at https://github.com/zendframework/zend-servicemanager/issues Online documentation Documentation source files","title":"zend-servicemanager"},{"location":"#benchmarks","text":"We provide scripts for benchmarking zend-servicemanager using the PHPBench framework; these can be found in the benchmarks/ directory. To execute the benchmarks you can run the following command: $ vendor/bin/phpbench run --report=aggregate","title":"Benchmarks"},{"location":"config-abstract-factory/","text":"Config Abstract Factory Since 3.2.0 You can simplify the process of creating factories by registering Zend\\ServiceManager\\AbstractFactory\\ConfigAbstractFactory with your service manager instance. This allows you to define services using a configuration map, rather than having to create separate factories for each of your services. Enabling the ConfigAbstractFactory Enable the ConfigAbstractFactory in the same way that you would enable any other abstract factory. Programmatically: $serviceManager = new ServiceManager(); $serviceManager->addAbstractFactory(new ConfigAbstractFactory()); Or within configuration: return [ // zend-mvc: 'service_manager' => [ 'abstract_factories' => [ ConfigAbstractFactory::class, ], ], // zend-expressive or ConfigProvider consumers: 'dependencies' => [ 'abstract_factories' => [ ConfigAbstractFactory::class, ], ], ]; Like all abstract factories starting in version 3, you may also use the config abstract factory as a mapped factory, registering it as a factory for a specific class: return [ 'service_manager' => [ 'factories' => [ SomeCustomClass::class => ConfigAbstractFactory::class, ], ], ]; Configuration Configuration should be provided via the config service, which should return an array or ArrayObject . ConfigAbstractFactory looks for a top-level key in this service named after itself (i.e., Zend\\ServiceManager\\AbstractFactory\\ConfigAbstractFactory ) that is an array value. Each item in the array: Should have a key representing the service name (typically the fully qualified class name) Should have a value that is an array of each dependency, ordered using the constructor argument order, and using service names registered with the container. As an example: use Zend\\ServiceManager\\AbstractFactory\\ConfigAbstractFactory; return [ ConfigAbstractFactory::class => [ MyInvokableClass::class => [], MySimpleClass::class => [ Logger::class, ], Logger::class => [ Handler::class, ], ], ]; The definition tells the service manager how this abstract factory should manage dependencies in the classes defined. In the above example, MySimpleClass has a single dependency on a Logger instance. The abstract factory will simply look to fulfil that dependency by calling get() with that key on the container passed to it. In this way, you can create the correct tree of dependencies to successfully return any given service. In the above example, note that the abstract factory configuration does not contain configuration for the Handler class. At first glance, this appears as if it will fail; however, if Handler is configured directly with the container already \u2014 for example, mapped to a custom factory \u2014 the service will be created and used as a dependency. As another, more complete example, consider the following classes: class UserMapper { public function __construct(Adapter $db, Cache $cache) {} } class Adapter { public function __construct(array $config) {} } class Cache { public function __construct(CacheAdapter $cacheAdapter) {} } class CacheAdapter { } In this case, we can define the configuration for these classes as follows: // config/autoload/dependencies.php or anywhere that gets merged into global config return [ ConfigAbstractFactory::class => [ CacheAdapter::class => [], // no dependencies Cache::class => [ CacheAdapter::class, // dependency on the CacheAdapter key defined above ], UserMapper::class => [ Adapter::class, // will be called using normal factory defined below Cache::class, // defined above and will be created using this abstract factory ], ], 'service_manager' => [ 'factories' => [ Adapter::class => AdapterFactory::class, // normal factory not using above config ], ], ],","title":"Configuration-based Abstract Factory"},{"location":"config-abstract-factory/#config-abstract-factory","text":"Since 3.2.0 You can simplify the process of creating factories by registering Zend\\ServiceManager\\AbstractFactory\\ConfigAbstractFactory with your service manager instance. This allows you to define services using a configuration map, rather than having to create separate factories for each of your services.","title":"Config Abstract Factory"},{"location":"config-abstract-factory/#enabling-the-configabstractfactory","text":"Enable the ConfigAbstractFactory in the same way that you would enable any other abstract factory. Programmatically: $serviceManager = new ServiceManager(); $serviceManager->addAbstractFactory(new ConfigAbstractFactory()); Or within configuration: return [ // zend-mvc: 'service_manager' => [ 'abstract_factories' => [ ConfigAbstractFactory::class, ], ], // zend-expressive or ConfigProvider consumers: 'dependencies' => [ 'abstract_factories' => [ ConfigAbstractFactory::class, ], ], ]; Like all abstract factories starting in version 3, you may also use the config abstract factory as a mapped factory, registering it as a factory for a specific class: return [ 'service_manager' => [ 'factories' => [ SomeCustomClass::class => ConfigAbstractFactory::class, ], ], ];","title":"Enabling the ConfigAbstractFactory"},{"location":"config-abstract-factory/#configuration","text":"Configuration should be provided via the config service, which should return an array or ArrayObject . ConfigAbstractFactory looks for a top-level key in this service named after itself (i.e., Zend\\ServiceManager\\AbstractFactory\\ConfigAbstractFactory ) that is an array value. Each item in the array: Should have a key representing the service name (typically the fully qualified class name) Should have a value that is an array of each dependency, ordered using the constructor argument order, and using service names registered with the container. As an example: use Zend\\ServiceManager\\AbstractFactory\\ConfigAbstractFactory; return [ ConfigAbstractFactory::class => [ MyInvokableClass::class => [], MySimpleClass::class => [ Logger::class, ], Logger::class => [ Handler::class, ], ], ]; The definition tells the service manager how this abstract factory should manage dependencies in the classes defined. In the above example, MySimpleClass has a single dependency on a Logger instance. The abstract factory will simply look to fulfil that dependency by calling get() with that key on the container passed to it. In this way, you can create the correct tree of dependencies to successfully return any given service. In the above example, note that the abstract factory configuration does not contain configuration for the Handler class. At first glance, this appears as if it will fail; however, if Handler is configured directly with the container already \u2014 for example, mapped to a custom factory \u2014 the service will be created and used as a dependency. As another, more complete example, consider the following classes: class UserMapper { public function __construct(Adapter $db, Cache $cache) {} } class Adapter { public function __construct(array $config) {} } class Cache { public function __construct(CacheAdapter $cacheAdapter) {} } class CacheAdapter { } In this case, we can define the configuration for these classes as follows: // config/autoload/dependencies.php or anywhere that gets merged into global config return [ ConfigAbstractFactory::class => [ CacheAdapter::class => [], // no dependencies Cache::class => [ CacheAdapter::class, // dependency on the CacheAdapter key defined above ], UserMapper::class => [ Adapter::class, // will be called using normal factory defined below Cache::class, // defined above and will be created using this abstract factory ], ], 'service_manager' => [ 'factories' => [ Adapter::class => AdapterFactory::class, // normal factory not using above config ], ], ],","title":"Configuration"},{"location":"configuring-the-service-manager/","text":"Configuring the service manager The Service Manager component can be configured by passing an associative array to the component's constructor. The following keys are: services : associative array that maps a key to a service instance. invokables : an associative array that maps a key to a constructor-less service; i.e., for services that do not require arguments to the constructor. The key and service name usually are the same; if they are not, the key is treated as an alias. factories : associative array that map a key to a factory name, or any callable. abstract_factories : a list of abstract factories classes. An abstract factory is a factory that can potentially create any object, based on some criterias. delegators : an associative array that maps service keys to lists of delegator factory keys, see the delegators documentation for more details. aliases : associative array that map a key to a service key (or another alias). initializers : a list of callable or initializers that are run whenever a service has been created. lazy_services : configuration for the lazy service proxy manager, and a class map of service:class pairs that will act as lazy services; see the lazy services documentation for more details. shared : associative array that maps a service name to a boolean, in order to indicate to the service manager whether or not it should cache services it creates via get method, independent of the shared_by_default setting. shared_by_default : boolean that indicates whether services created through the get method should be cached. This is true by default. Here is an example of how you could configure a service manager: use Zend\\ServiceManager\\ServiceManager; $serviceManager = new ServiceManager([ 'services' => [], 'invokables' => [], 'factories' => [], 'abstract_factories' => [], 'delegators' => [], 'aliases' => [], 'initializers' => [], 'lazy_services' => [], 'shared' => [], 'shared_by_default' => true, ]); Factories A factory is any callable or any class that implements the interface Zend\\ServiceManager\\Factory\\FactoryInterface . Service manager components provide a default factory that can be used to create objects that do not have any dependencies: use Zend\\ServiceManager\\Factory\\InvokableFactory; use Zend\\ServiceManager\\ServiceManager; use stdClass; $serviceManager = new ServiceManager([ 'factories' => [ MyObject::class => MyObjectFactory::class, ], ]); For invokable classes we can use Zend\\ServiceManager\\Factory\\InvokableFactory but for performance reasons using invokables configuration is recommended. As said before, a factory can also be a callable, to create more complex objects: use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\Factory\\InvokableFactory; use Zend\\ServiceManager\\ServiceManager; use stdClass; $serviceManager = new ServiceManager([ 'factories' => [ stdClass::class => InvokableFactory::class, MyObject::class => function(ContainerInterface $container, $requestedName) { $dependency = $container->get(stdClass::class); return new MyObject($dependency); }, ], ]); Each factory always receive a ContainerInterface argument (this is the base interface that the ServiceManager implements), as well as the requested name as the second argument. In this case, the $requestedName is MyObject . Alternatively, the above code can be replaced by a factory class instead of a closure. This leads to more readable code. For instance: // In MyObjectFactory.php file class MyObjectFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $dependency = $container->get(stdClass::class); return new MyObject($dependency); } } // or without implementing the interface: class MyObjectFactory { public function __invoke(ContainerInterface $container, $requestedName) { $dependency = $container->get(Dependency::class); return new MyObject($dependency); } } // When creating the service manager: $serviceManager = new ServiceManager([ 'factories' => [ stdClass::class => InvokableFactory::class, MyObject::class => MyObjectFactory::class ] ]); For performance reasons, factories objects are not created until requested. In the above example, this means that the MyObjectFactory object won't be created until MyObject is requested. Mapping multiple service to the same factory Unlike version 2 implementations of the component, in the version 3 implementation, the $requestedName is guaranteed to be passed as the second parameter of a factory. This is useful when you need to create multiple services that are created exactly the same way, hence reducing the number of needed factories. For instance, if two services share the same creation pattern, you could attach the same factory: // In MyObjectFactory.php file class MyObjectFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $dependency = $container->get(stdClass::class); return new $requestedName($dependency); } } // or without implementing the interface: class MyObjectFactory { public function __invoke(ContainerInterface $container, $requestedName) { $dependency = $container->get(Dependency::class); return new $requestedName($dependency); } } // When creating the service manager: $serviceManager = new ServiceManager([ 'factories' => [ MyObjectA::class => MyObjectFactory::class, MyObjectB::class => MyObjectFactory::class ] ]); This pattern can often replace abstract factories, and is more performant: Lookups for services do not need to query abstract factories; the service is mapped explicitly. Once the factory is loaded for any object, it stays in memory for any other service using the same factory. Using factories is recommended in most cases where abstract factories were used in version 2. This feature can be abused, however: for instance, if you have dozens of services that share the same creation, but which do not share any common functionality, we recommend to create separate factories. Abstract factories An abstract factory is a specialized factory that can be used to create any service, if it has the capability to do so. An abstract factory is often useful when you do not know in advance the name of the service (e.g. if the service name is generated dynamically at runtime), but know that the services share a common creation pattern. An abstract factory must be registered inside the service manager, and is checked if no factory can create an object. Each abstract factory must implement Zend\\ServiceManager\\Factory\\AbstractFactoryInterface : // In MyAbstractFactory.php: class MyAbstractFactory implements AbstractFactoryInterface { public function canCreate(ContainerInterface $container, $requestedName) { return in_array('Traversable', class_implements($requestedName), true); } public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { return $requestedName(); } } // When creating the service manager: $serviceManager = new ServiceManager([ 'abstract_factories' => [ new MyAbstractFactory() // You could also pass a class name: MyAbstractFactory::class ] ]); // When fetching an object: $object = $serviceManager->get(A::class); Here is what will happen: The service manager will check if it contains a factory mapped to the A::class service. Because none is found, it will process each abstract factory, in the order in which they were registered. It will call the canCreate() method, passing the service manager instance and the name of the requested object. The method can use any logic whatsoever to determine if it can create the service (such as checking its name, checking for a required dependency in the passed container, checking if a class implements a given interface, etc.). If canCreate() returns true , it will call the __invoke method to create the object. Otherwise, it will continue iterating the abstract factories, until one matches, or the queue is exhausted. Best practices While convenient, we recommend you to limit the number of abstract factories. Because the service manager needs to iterate through all registered abstract factories to resolve services, it can be costly when multiple abstract factories are present. Often, mapping the same factory to multiple services can solve the issue more efficiently (as described in the Factories section). Aliases An alias provides an alternative name for a registered service. An alias can also be mapped to another alias (it will be resolved recursively). For instance: use Zend\\ServiceManager\\Factory\\InvokableFactory; use Zend\\ServiceManager\\ServiceManager; use stdClass; $serviceManager = new ServiceManager([ 'factories' => [ stdClass::class => InvokableFactory::class ], 'aliases' => [ 'A' => stdClass::class, 'B' => 'A' ] ]); $object = $serviceManager->get('B'); In this example, asking B will be resolved to A , which will be itself resolved to stdClass::class , which will finally be constructed using the provided factory. Best practices We recommend you minimal use of aliases, and instead using the ::class language construct to map using a FQCN (Fully-Qualified-Class-Name). This provides both better discoverability within your code, and allows simpler refactoring, as most modern IDEs can refactor class names specified using the ::class keyword. Initializers An initializer is any callable or any class that implements the interface Zend\\ServiceManager\\Initializer\\InitializerInterface . Initializers are executed for each service the first time they are created, and can be used to inject additional dependencies. For instance, if we'd want to automatically inject the dependency EventManager::class in all objects that implement the interface EventManagerAwareInterface , we could create the following initializer: use Interop\\Container\\ContainerInterface; use stdClass; use Zend\\ServiceManager\\ServiceManager; $serviceManager = new ServiceManager([ 'initializers' => [ function(ContainerInterface $container, $instance) { if (! $instance instanceof EventManagerAwareInterface) { return; } $instance->setEventManager($container->get(EventManager::class)); } ] ]); Alternately, you can create a class that implements Zend\\ServiceManager\\Initializer\\InitializerInterface , and pass it to the initializers array: // In MyInitializer.php class MyInitializer implements InitializerInterface { public function __invoke(ContainerInterface $container, $instance) { if (! $instance instanceof EventManagerAwareInterface) { return; } $instance->setEventManager($container->get(EventManager::class)); } } // When creating the service manager: use Interop\\Container\\ContainerInterface; use stdClass; use Zend\\ServiceManager\\ServiceManager; $serviceManager = new ServiceManager([ 'initializers' => [ new MyInitializer() // You could also use MyInitializer::class ] ]); Note that initializers are automatically created when the service manager is initialized, even if you pass a class name. Best practices While convenient, initializer usage is also problematic. They are provided primarily for backwards compatibility, but we highly discourage their usage. The primary issues with initializers are: They lead to fragile code. Because the dependency is not injected directly in the constructor, it means that the object may be in an \"incomplete state\". If for any reason the initializer is not run (if it was not correctly registered for instance), bugs ranging from the subtle to fatal can be introduced. Instead, we encourage you to inject all necessary dependencies via the constructor, using factories. If some dependencies use setter or interface injection, use delegator factories. If a given service has too many dependencies, then it may be a sign that you need to split this service into smaller, more focused services. They are slow: an initializer is run for EVERY instance you create through the service manager. If you have ten initializers or more, this can quickly add up! Shared By default, a service created is shared. This means that calling the get() method twice for a given service will return exactly the same service. This is typically what you want, as it can save a lot of memory and increase performance: $serviceManager = new ServiceManager([ 'factories' => [ stdClass::class => InvokableFactory::class ] ]); $object1 = $serviceManager->get(stdClass::class); $object2 = $serviceManager->get(stdClass::class); var_dump($object1 === $object2); // prints \"true\" However, occasionally you may require discrete instances of a service. To enable this, you can use the shared key, providing a boolean false value for your service, as shown below: $serviceManager = new ServiceManager([ 'factories' => [ stdClass::class => InvokableFactory::class ], 'shared' => [ stdClass::class => false ] ]); $object1 = $serviceManager->get(stdClass::class); $object2 = $serviceManager->get(stdClass::class); var_dump($object1 === $object2); // prints \"false\" Alternately, you can use the build() method instead of the get() method. The build() method works exactly the same as the get method, but never caches the service created, nor uses a previously cached instance for the service. $serviceManager = new ServiceManager([ 'factories' => [ stdClass::class => InvokableFactory::class ] ]); $object1 = $serviceManager->build(stdClass::class); $object2 = $serviceManager->build(stdClass::class); var_dump($object1 === $object2); // prints \"false\" Finally, you could also decide to disable caching by default (even when calling the get() method), by setting the shared_by_default option to false: $serviceManager = new ServiceManager([ 'factories' => [ stdClass::class => InvokableFactory::class ], 'shared_by_default' => false, ]); $object1 = $serviceManager->get(stdClass::class); $object2 = $serviceManager->get(stdClass::class); var_dump($object1 === $object2); // prints \"false\" Passing config to a factory/delegator So far, we have covered examples where services are created through factories (or abstract factories). The factory is able to create the object itself. Occasionally you may need to pass additional options that act as a \"context\". For instance, we could have a StringLengthValidator service registered. However, this validator can have multiple options, such as min and max . Because this is dependant on the caller context (or might even be retrieved from a database, for instance), the factory cannot know what options to give when constructing the validator. To solve this issue, the service manager offers a build() method. It works similarly to the get() method, with two main differences: Services created with the build() method are never cached , nor pulled from previously cached instances for that service. build() accepts an optional secondary parameter, an array of options. Those options are transferred to all factories, abstract factories, and delegators. For instance: // In StringLengthValidatorFactory.php class StringLengthValidatorFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = []) { return new StringLengthValidator($options); } } // When creating the service manager: $serviceManager = new ServiceManager([ 'factories' => [ StringLengthValidator::class => StringLengthValidatorFactory::class ] ]); // When creating the objects: $validator1 = $serviceManager->build(StringLengthValidator::class, ['min' => 5]); $validator2 = $serviceManager->build(StringLengthValidator::class, ['min' => 15]); In our previous example, because the StringLengthValidator does not have any other dependencies other than the $options , we could remove the factory, and simply map it to the built-in InvokableFactory factory: // When creating the service manager: $serviceManager = new ServiceManager([ 'factories' => [ StringLengthValidator::class => InvokableFactory::class ] ]); // When creating the objects: $validator1 = $serviceManager->build(StringLengthValidator::class, ['min' => 5]); $validator2 = $serviceManager->build(StringLengthValidator::class, ['min' => 15]); This works because the InvokableFactory will automatically pass the options (if any) to the constructor of the created object. Altering a service manager's config Assuming that you have not called $container->setAllowOverride(false) , you can, at any time, configure the service manager with new services using any of the following methods: configure() , which accepts the same configuration array as the constructor. setAlias($alias, $target) setInvokableClass($name, $class = null) ; if no $class is passed, the assumption is that $name is the class name. setFactory($name, $factory) , where $factory can be either a callable factory or the name of a factory class to use. mapLazyService($name, $class = null) , to map the service name $name to $class ; if the latter is not provided, $name is used for both sides of the map. addAbstractFactory($factory) , where $factory can be either a Zend\\ServiceManager\\Factory\\AbstractFactoryInterface instance or the name of a class implementing the interface. addDelegator($name, $factory) , where $factory can be either a callable delegator factory, or the name of a delegator factory class to use. addInitializer($initializer) , where $initializer can be either a callable initializer, or the name of an initializer class to use. setService($name, $instance) setShared($name, $shared) , where $shared is a boolean flag indicating whether or not the named service should be shared. As examples: use Zend\\ServiceManager\\ServiceManager; $serviceManager = new ServiceManager([ 'factories' => [ stdClass::class => InvokableFactory::class; ] ]); $serviceManager->configure([ 'factories' => [ DateTime::class => InvokableFactory::class ] ]); var_dump($newServiceManager->has(DateTime::class)); // prints true // Create an alias from 'Date' to 'DateTime' $serviceManager->setAlias('Date', DateTime::class); // Set a factory for the 'Time' service $serviceManager->setFactory('Time', function ($container) { return $container->get(DateTime::class); }); // Map a lazy service named 'localtime' to the class DateTime. $serviceManager->mapLazyService('localtime', DateTime::class); // Add an abstract factory $serviceManager->addAbstractFactory(new CustomAbstractFactory()); // Add a delegator factory for the DateTime service $serviceManager->addDelegator(DateTime::class, function ($container, $name, $callback) { $dateTime = $callback(); $dateTime->setTimezone(new DateTimezone('UTC')); return $dateTime; }); // Add an initializer // Note: don't do this. Use delegator factories instead. $serviceManager->addInitializer(function ($service, $instance) { if (! $instance instanceof DateTime) { return; } $instance->setTimezone(new DateTimezone('America/Chicago')); }) // Explicitly map a service name to an instance. $serviceManager->setService('foo', new stdClass); // Mark the DateTime service as NOT being shared. $serviceManager->setShared(DateTime::class, false);","title":"Configuring the service manager"},{"location":"configuring-the-service-manager/#configuring-the-service-manager","text":"The Service Manager component can be configured by passing an associative array to the component's constructor. The following keys are: services : associative array that maps a key to a service instance. invokables : an associative array that maps a key to a constructor-less service; i.e., for services that do not require arguments to the constructor. The key and service name usually are the same; if they are not, the key is treated as an alias. factories : associative array that map a key to a factory name, or any callable. abstract_factories : a list of abstract factories classes. An abstract factory is a factory that can potentially create any object, based on some criterias. delegators : an associative array that maps service keys to lists of delegator factory keys, see the delegators documentation for more details. aliases : associative array that map a key to a service key (or another alias). initializers : a list of callable or initializers that are run whenever a service has been created. lazy_services : configuration for the lazy service proxy manager, and a class map of service:class pairs that will act as lazy services; see the lazy services documentation for more details. shared : associative array that maps a service name to a boolean, in order to indicate to the service manager whether or not it should cache services it creates via get method, independent of the shared_by_default setting. shared_by_default : boolean that indicates whether services created through the get method should be cached. This is true by default. Here is an example of how you could configure a service manager: use Zend\\ServiceManager\\ServiceManager; $serviceManager = new ServiceManager([ 'services' => [], 'invokables' => [], 'factories' => [], 'abstract_factories' => [], 'delegators' => [], 'aliases' => [], 'initializers' => [], 'lazy_services' => [], 'shared' => [], 'shared_by_default' => true, ]);","title":"Configuring the service manager"},{"location":"configuring-the-service-manager/#factories","text":"A factory is any callable or any class that implements the interface Zend\\ServiceManager\\Factory\\FactoryInterface . Service manager components provide a default factory that can be used to create objects that do not have any dependencies: use Zend\\ServiceManager\\Factory\\InvokableFactory; use Zend\\ServiceManager\\ServiceManager; use stdClass; $serviceManager = new ServiceManager([ 'factories' => [ MyObject::class => MyObjectFactory::class, ], ]); For invokable classes we can use Zend\\ServiceManager\\Factory\\InvokableFactory but for performance reasons using invokables configuration is recommended. As said before, a factory can also be a callable, to create more complex objects: use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\Factory\\InvokableFactory; use Zend\\ServiceManager\\ServiceManager; use stdClass; $serviceManager = new ServiceManager([ 'factories' => [ stdClass::class => InvokableFactory::class, MyObject::class => function(ContainerInterface $container, $requestedName) { $dependency = $container->get(stdClass::class); return new MyObject($dependency); }, ], ]); Each factory always receive a ContainerInterface argument (this is the base interface that the ServiceManager implements), as well as the requested name as the second argument. In this case, the $requestedName is MyObject . Alternatively, the above code can be replaced by a factory class instead of a closure. This leads to more readable code. For instance: // In MyObjectFactory.php file class MyObjectFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $dependency = $container->get(stdClass::class); return new MyObject($dependency); } } // or without implementing the interface: class MyObjectFactory { public function __invoke(ContainerInterface $container, $requestedName) { $dependency = $container->get(Dependency::class); return new MyObject($dependency); } } // When creating the service manager: $serviceManager = new ServiceManager([ 'factories' => [ stdClass::class => InvokableFactory::class, MyObject::class => MyObjectFactory::class ] ]); For performance reasons, factories objects are not created until requested. In the above example, this means that the MyObjectFactory object won't be created until MyObject is requested.","title":"Factories"},{"location":"configuring-the-service-manager/#abstract-factories","text":"An abstract factory is a specialized factory that can be used to create any service, if it has the capability to do so. An abstract factory is often useful when you do not know in advance the name of the service (e.g. if the service name is generated dynamically at runtime), but know that the services share a common creation pattern. An abstract factory must be registered inside the service manager, and is checked if no factory can create an object. Each abstract factory must implement Zend\\ServiceManager\\Factory\\AbstractFactoryInterface : // In MyAbstractFactory.php: class MyAbstractFactory implements AbstractFactoryInterface { public function canCreate(ContainerInterface $container, $requestedName) { return in_array('Traversable', class_implements($requestedName), true); } public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { return $requestedName(); } } // When creating the service manager: $serviceManager = new ServiceManager([ 'abstract_factories' => [ new MyAbstractFactory() // You could also pass a class name: MyAbstractFactory::class ] ]); // When fetching an object: $object = $serviceManager->get(A::class); Here is what will happen: The service manager will check if it contains a factory mapped to the A::class service. Because none is found, it will process each abstract factory, in the order in which they were registered. It will call the canCreate() method, passing the service manager instance and the name of the requested object. The method can use any logic whatsoever to determine if it can create the service (such as checking its name, checking for a required dependency in the passed container, checking if a class implements a given interface, etc.). If canCreate() returns true , it will call the __invoke method to create the object. Otherwise, it will continue iterating the abstract factories, until one matches, or the queue is exhausted.","title":"Abstract factories"},{"location":"configuring-the-service-manager/#aliases","text":"An alias provides an alternative name for a registered service. An alias can also be mapped to another alias (it will be resolved recursively). For instance: use Zend\\ServiceManager\\Factory\\InvokableFactory; use Zend\\ServiceManager\\ServiceManager; use stdClass; $serviceManager = new ServiceManager([ 'factories' => [ stdClass::class => InvokableFactory::class ], 'aliases' => [ 'A' => stdClass::class, 'B' => 'A' ] ]); $object = $serviceManager->get('B'); In this example, asking B will be resolved to A , which will be itself resolved to stdClass::class , which will finally be constructed using the provided factory.","title":"Aliases"},{"location":"configuring-the-service-manager/#initializers","text":"An initializer is any callable or any class that implements the interface Zend\\ServiceManager\\Initializer\\InitializerInterface . Initializers are executed for each service the first time they are created, and can be used to inject additional dependencies. For instance, if we'd want to automatically inject the dependency EventManager::class in all objects that implement the interface EventManagerAwareInterface , we could create the following initializer: use Interop\\Container\\ContainerInterface; use stdClass; use Zend\\ServiceManager\\ServiceManager; $serviceManager = new ServiceManager([ 'initializers' => [ function(ContainerInterface $container, $instance) { if (! $instance instanceof EventManagerAwareInterface) { return; } $instance->setEventManager($container->get(EventManager::class)); } ] ]); Alternately, you can create a class that implements Zend\\ServiceManager\\Initializer\\InitializerInterface , and pass it to the initializers array: // In MyInitializer.php class MyInitializer implements InitializerInterface { public function __invoke(ContainerInterface $container, $instance) { if (! $instance instanceof EventManagerAwareInterface) { return; } $instance->setEventManager($container->get(EventManager::class)); } } // When creating the service manager: use Interop\\Container\\ContainerInterface; use stdClass; use Zend\\ServiceManager\\ServiceManager; $serviceManager = new ServiceManager([ 'initializers' => [ new MyInitializer() // You could also use MyInitializer::class ] ]); Note that initializers are automatically created when the service manager is initialized, even if you pass a class name.","title":"Initializers"},{"location":"configuring-the-service-manager/#shared","text":"By default, a service created is shared. This means that calling the get() method twice for a given service will return exactly the same service. This is typically what you want, as it can save a lot of memory and increase performance: $serviceManager = new ServiceManager([ 'factories' => [ stdClass::class => InvokableFactory::class ] ]); $object1 = $serviceManager->get(stdClass::class); $object2 = $serviceManager->get(stdClass::class); var_dump($object1 === $object2); // prints \"true\" However, occasionally you may require discrete instances of a service. To enable this, you can use the shared key, providing a boolean false value for your service, as shown below: $serviceManager = new ServiceManager([ 'factories' => [ stdClass::class => InvokableFactory::class ], 'shared' => [ stdClass::class => false ] ]); $object1 = $serviceManager->get(stdClass::class); $object2 = $serviceManager->get(stdClass::class); var_dump($object1 === $object2); // prints \"false\" Alternately, you can use the build() method instead of the get() method. The build() method works exactly the same as the get method, but never caches the service created, nor uses a previously cached instance for the service. $serviceManager = new ServiceManager([ 'factories' => [ stdClass::class => InvokableFactory::class ] ]); $object1 = $serviceManager->build(stdClass::class); $object2 = $serviceManager->build(stdClass::class); var_dump($object1 === $object2); // prints \"false\" Finally, you could also decide to disable caching by default (even when calling the get() method), by setting the shared_by_default option to false: $serviceManager = new ServiceManager([ 'factories' => [ stdClass::class => InvokableFactory::class ], 'shared_by_default' => false, ]); $object1 = $serviceManager->get(stdClass::class); $object2 = $serviceManager->get(stdClass::class); var_dump($object1 === $object2); // prints \"false\"","title":"Shared"},{"location":"configuring-the-service-manager/#passing-config-to-a-factorydelegator","text":"So far, we have covered examples where services are created through factories (or abstract factories). The factory is able to create the object itself. Occasionally you may need to pass additional options that act as a \"context\". For instance, we could have a StringLengthValidator service registered. However, this validator can have multiple options, such as min and max . Because this is dependant on the caller context (or might even be retrieved from a database, for instance), the factory cannot know what options to give when constructing the validator. To solve this issue, the service manager offers a build() method. It works similarly to the get() method, with two main differences: Services created with the build() method are never cached , nor pulled from previously cached instances for that service. build() accepts an optional secondary parameter, an array of options. Those options are transferred to all factories, abstract factories, and delegators. For instance: // In StringLengthValidatorFactory.php class StringLengthValidatorFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = []) { return new StringLengthValidator($options); } } // When creating the service manager: $serviceManager = new ServiceManager([ 'factories' => [ StringLengthValidator::class => StringLengthValidatorFactory::class ] ]); // When creating the objects: $validator1 = $serviceManager->build(StringLengthValidator::class, ['min' => 5]); $validator2 = $serviceManager->build(StringLengthValidator::class, ['min' => 15]); In our previous example, because the StringLengthValidator does not have any other dependencies other than the $options , we could remove the factory, and simply map it to the built-in InvokableFactory factory: // When creating the service manager: $serviceManager = new ServiceManager([ 'factories' => [ StringLengthValidator::class => InvokableFactory::class ] ]); // When creating the objects: $validator1 = $serviceManager->build(StringLengthValidator::class, ['min' => 5]); $validator2 = $serviceManager->build(StringLengthValidator::class, ['min' => 15]); This works because the InvokableFactory will automatically pass the options (if any) to the constructor of the created object.","title":"Passing config to a factory/delegator"},{"location":"configuring-the-service-manager/#altering-a-service-managers-config","text":"Assuming that you have not called $container->setAllowOverride(false) , you can, at any time, configure the service manager with new services using any of the following methods: configure() , which accepts the same configuration array as the constructor. setAlias($alias, $target) setInvokableClass($name, $class = null) ; if no $class is passed, the assumption is that $name is the class name. setFactory($name, $factory) , where $factory can be either a callable factory or the name of a factory class to use. mapLazyService($name, $class = null) , to map the service name $name to $class ; if the latter is not provided, $name is used for both sides of the map. addAbstractFactory($factory) , where $factory can be either a Zend\\ServiceManager\\Factory\\AbstractFactoryInterface instance or the name of a class implementing the interface. addDelegator($name, $factory) , where $factory can be either a callable delegator factory, or the name of a delegator factory class to use. addInitializer($initializer) , where $initializer can be either a callable initializer, or the name of an initializer class to use. setService($name, $instance) setShared($name, $shared) , where $shared is a boolean flag indicating whether or not the named service should be shared. As examples: use Zend\\ServiceManager\\ServiceManager; $serviceManager = new ServiceManager([ 'factories' => [ stdClass::class => InvokableFactory::class; ] ]); $serviceManager->configure([ 'factories' => [ DateTime::class => InvokableFactory::class ] ]); var_dump($newServiceManager->has(DateTime::class)); // prints true // Create an alias from 'Date' to 'DateTime' $serviceManager->setAlias('Date', DateTime::class); // Set a factory for the 'Time' service $serviceManager->setFactory('Time', function ($container) { return $container->get(DateTime::class); }); // Map a lazy service named 'localtime' to the class DateTime. $serviceManager->mapLazyService('localtime', DateTime::class); // Add an abstract factory $serviceManager->addAbstractFactory(new CustomAbstractFactory()); // Add a delegator factory for the DateTime service $serviceManager->addDelegator(DateTime::class, function ($container, $name, $callback) { $dateTime = $callback(); $dateTime->setTimezone(new DateTimezone('UTC')); return $dateTime; }); // Add an initializer // Note: don't do this. Use delegator factories instead. $serviceManager->addInitializer(function ($service, $instance) { if (! $instance instanceof DateTime) { return; } $instance->setTimezone(new DateTimezone('America/Chicago')); }) // Explicitly map a service name to an instance. $serviceManager->setService('foo', new stdClass); // Mark the DateTime service as NOT being shared. $serviceManager->setShared(DateTime::class, false);","title":"Altering a service manager's config"},{"location":"console-tools/","text":"Console Tools Starting in 3.2.0, zend-servicemanager began shipping with console tools. This document details each. generate-deps-for-config-factory $ ./vendor/bin/generate-deps-for-config-factory Usage: generate-deps-for-config-factory [-h|--help|help] [-i|--ignore-unresolved] <configFile> <className> Arguments: -h|--help|help This usage message -i|--ignore-unresolved Ignore classes with unresolved direct dependencies. <configFile> Path to a config file for which to generate configuration. If the file does not exist, it will be created. If it does exist, it must return an array, and the file will be updated with new configuration. <className> Name of the class to reflect and for which to generate dependency configuration. Reads the provided configuration file (creating it if it does not exist), and injects it with ConfigAbstractFactory dependency configuration for the provided class name, writing the changes back to the file. This utility will generate dependency configuration for the named class for use with the ConfigAbstractFactory . When doing so, it will read the named configuration file (creating it if it does not exist), and merge any configuration it generates with the return values of that file, writing the changes back to the original file. Since 3.2.1, the tool also supports the -i or --ignore-unresolved flag. Use these flags when you have typehints to classes that cannot be resolved. When you omit the flag, such classes will cause the tool to fail with an exception message. By adding the flag, you can have it continue and produce configuration. This option is particularly useful when typehints are on interfaces or resolve to services served by other abstract factories. generate-factory-for-class $ ./vendor/bin/generate-factory-for-class Usage: ./bin/generate-factory-for-class [-h|--help|help] <className> Arguments: -h|--help|help This usage message <className> Name of the class to reflect and for which to generate a factory. Generates to STDOUT a factory for creating the specified class; this may then be added to your application, and configured as a factory for the class. This utility generates a factory class for the given class, based on the typehints in its constructor. The factory is emitted to STDOUT, and may be piped to a file if desired: $ ./vendor/bin/generate-factory-for-class \\ > \"Application\\\\Model\\\\AlbumModel\" > ./module/Application/src/Model/AlbumModelFactory.php The class generated implements Zend\\ServiceManager\\Factory\\FactoryInterface , and is generated within the same namespace as the originating class.","title":"Console Tools"},{"location":"console-tools/#console-tools","text":"Starting in 3.2.0, zend-servicemanager began shipping with console tools. This document details each.","title":"Console Tools"},{"location":"console-tools/#generate-deps-for-config-factory","text":"$ ./vendor/bin/generate-deps-for-config-factory Usage: generate-deps-for-config-factory [-h|--help|help] [-i|--ignore-unresolved] <configFile> <className> Arguments: -h|--help|help This usage message -i|--ignore-unresolved Ignore classes with unresolved direct dependencies. <configFile> Path to a config file for which to generate configuration. If the file does not exist, it will be created. If it does exist, it must return an array, and the file will be updated with new configuration. <className> Name of the class to reflect and for which to generate dependency configuration. Reads the provided configuration file (creating it if it does not exist), and injects it with ConfigAbstractFactory dependency configuration for the provided class name, writing the changes back to the file. This utility will generate dependency configuration for the named class for use with the ConfigAbstractFactory . When doing so, it will read the named configuration file (creating it if it does not exist), and merge any configuration it generates with the return values of that file, writing the changes back to the original file. Since 3.2.1, the tool also supports the -i or --ignore-unresolved flag. Use these flags when you have typehints to classes that cannot be resolved. When you omit the flag, such classes will cause the tool to fail with an exception message. By adding the flag, you can have it continue and produce configuration. This option is particularly useful when typehints are on interfaces or resolve to services served by other abstract factories.","title":"generate-deps-for-config-factory"},{"location":"console-tools/#generate-factory-for-class","text":"$ ./vendor/bin/generate-factory-for-class Usage: ./bin/generate-factory-for-class [-h|--help|help] <className> Arguments: -h|--help|help This usage message <className> Name of the class to reflect and for which to generate a factory. Generates to STDOUT a factory for creating the specified class; this may then be added to your application, and configured as a factory for the class. This utility generates a factory class for the given class, based on the typehints in its constructor. The factory is emitted to STDOUT, and may be piped to a file if desired: $ ./vendor/bin/generate-factory-for-class \\ > \"Application\\\\Model\\\\AlbumModel\" > ./module/Application/src/Model/AlbumModelFactory.php The class generated implements Zend\\ServiceManager\\Factory\\FactoryInterface , and is generated within the same namespace as the originating class.","title":"generate-factory-for-class"},{"location":"delegators/","text":"Delegators Zend\\ServiceManager can instantiate delegators of requested services, decorating them as specified in a delegate factory implementing the delegator factory interface . The delegate pattern is useful in cases when you want to wrap a real service in a decorator , or generally intercept actions being performed on the delegate in an AOP fashioned way. Delegator factory signature A delegator factory has the following signature: use Interop\\Container\\ContainerInterface; public function __invoke( ContainerInterface $container, $name, callable $callback, array $options = null ); The parameters passed to the delegator factory are the following: $container is the service locator that is used while creating the delegator for the requested service. $name is the name of the service being requested. $callback is a callable that is responsible for instantiating the delegated service (the real service instance). $options is an array of options to use when creating the instance; these are typically used only during build() operations. A Delegator factory use case A typical use case for delegators is to handle logic before or after a method is called. In the following example, an event is being triggered before Buzzer::buzz() is called and some output text is prepended. The delegated object Buzzer (original object) is defined as following: class Buzzer { public function buzz() { return 'Buzz!'; } } The delegator class BuzzerDelegator has the following structure: use Zend\\EventManager\\EventManagerInterface; class BuzzerDelegator extends Buzzer { protected $realBuzzer; protected $eventManager; public function __construct(Buzzer $realBuzzer, EventManagerInterface $eventManager) { $this->realBuzzer = $realBuzzer; $this->eventManager = $eventManager; } public function buzz() { $this->eventManager->trigger('buzz', $this); return $this->realBuzzer->buzz(); } } To use the BuzzerDelegator , you can run the following code: $wrappedBuzzer = new Buzzer(); $eventManager = new Zend\\EventManager\\EventManager(); $eventManager->attach('buzz', function () { echo \"Stare at the art!\\n\"; }); $buzzer = new BuzzerDelegator($wrappedBuzzer, $eventManager); echo $buzzer->buzz(); // \"Stare at the art!\\nBuzz!\" This logic is fairly simple as long as you have access to the instantiation logic of the $wrappedBuzzer object. You may not always be able to define how $wrappedBuzzer is created, since a factory for it may be defined by some code to which you don't have access, or which you cannot modify without introducing further complexity. Delegator factories solve this specific problem by allowing you to wrap, decorate or modify any existing service. A simple delegator factory for the buzzer service can be implemented as following: use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\Factory\\DelegatorFactoryInterface; class BuzzerDelegatorFactory implements DelegatorFactoryInterface { public function __invoke(ContainerInterface $container, $name, callable $callback, array $options = null) { $realBuzzer = call_user_func($callback); $eventManager = $container->get('EventManager'); $eventManager->attach('buzz', function () { echo \"Stare at the art!\\n\"; }); return new BuzzerDelegator($realBuzzer, $eventManager); } } You can then instruct the service manager to handle the service buzzer as a delegate: use Zend\\ServiceManager\\Factory\\InvokableFactory; use Zend\\ServiceManager\\ServiceManager; $serviceManager = new Zend\\ServiceManager\\ServiceManager([ 'factories' => [ Buzzer::class => InvokableFactory::class, ], 'delegators' => [ Buzzer::class => [ BuzzerDelegatorFactory::class, ], ], ]); // now, when fetching Buzzer, we get a BuzzerDelegator instead $buzzer = $serviceManager->get(Buzzer::class); $buzzer->buzz(); // \"Stare at the art!\\nBuzz!\" You can specify multiple delegators for a service. Each will add one decorator around the instantiation logic of that particular service. This latter point is the primary use case for delegators: decorating the instantiation logic for a service .","title":"Delegators"},{"location":"delegators/#delegators","text":"Zend\\ServiceManager can instantiate delegators of requested services, decorating them as specified in a delegate factory implementing the delegator factory interface . The delegate pattern is useful in cases when you want to wrap a real service in a decorator , or generally intercept actions being performed on the delegate in an AOP fashioned way.","title":"Delegators"},{"location":"delegators/#delegator-factory-signature","text":"A delegator factory has the following signature: use Interop\\Container\\ContainerInterface; public function __invoke( ContainerInterface $container, $name, callable $callback, array $options = null ); The parameters passed to the delegator factory are the following: $container is the service locator that is used while creating the delegator for the requested service. $name is the name of the service being requested. $callback is a callable that is responsible for instantiating the delegated service (the real service instance). $options is an array of options to use when creating the instance; these are typically used only during build() operations.","title":"Delegator factory signature"},{"location":"delegators/#a-delegator-factory-use-case","text":"A typical use case for delegators is to handle logic before or after a method is called. In the following example, an event is being triggered before Buzzer::buzz() is called and some output text is prepended. The delegated object Buzzer (original object) is defined as following: class Buzzer { public function buzz() { return 'Buzz!'; } } The delegator class BuzzerDelegator has the following structure: use Zend\\EventManager\\EventManagerInterface; class BuzzerDelegator extends Buzzer { protected $realBuzzer; protected $eventManager; public function __construct(Buzzer $realBuzzer, EventManagerInterface $eventManager) { $this->realBuzzer = $realBuzzer; $this->eventManager = $eventManager; } public function buzz() { $this->eventManager->trigger('buzz', $this); return $this->realBuzzer->buzz(); } } To use the BuzzerDelegator , you can run the following code: $wrappedBuzzer = new Buzzer(); $eventManager = new Zend\\EventManager\\EventManager(); $eventManager->attach('buzz', function () { echo \"Stare at the art!\\n\"; }); $buzzer = new BuzzerDelegator($wrappedBuzzer, $eventManager); echo $buzzer->buzz(); // \"Stare at the art!\\nBuzz!\" This logic is fairly simple as long as you have access to the instantiation logic of the $wrappedBuzzer object. You may not always be able to define how $wrappedBuzzer is created, since a factory for it may be defined by some code to which you don't have access, or which you cannot modify without introducing further complexity. Delegator factories solve this specific problem by allowing you to wrap, decorate or modify any existing service. A simple delegator factory for the buzzer service can be implemented as following: use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\Factory\\DelegatorFactoryInterface; class BuzzerDelegatorFactory implements DelegatorFactoryInterface { public function __invoke(ContainerInterface $container, $name, callable $callback, array $options = null) { $realBuzzer = call_user_func($callback); $eventManager = $container->get('EventManager'); $eventManager->attach('buzz', function () { echo \"Stare at the art!\\n\"; }); return new BuzzerDelegator($realBuzzer, $eventManager); } } You can then instruct the service manager to handle the service buzzer as a delegate: use Zend\\ServiceManager\\Factory\\InvokableFactory; use Zend\\ServiceManager\\ServiceManager; $serviceManager = new Zend\\ServiceManager\\ServiceManager([ 'factories' => [ Buzzer::class => InvokableFactory::class, ], 'delegators' => [ Buzzer::class => [ BuzzerDelegatorFactory::class, ], ], ]); // now, when fetching Buzzer, we get a BuzzerDelegator instead $buzzer = $serviceManager->get(Buzzer::class); $buzzer->buzz(); // \"Stare at the art!\\nBuzz!\" You can specify multiple delegators for a service. Each will add one decorator around the instantiation logic of that particular service. This latter point is the primary use case for delegators: decorating the instantiation logic for a service .","title":"A Delegator factory use case"},{"location":"lazy-services/","text":"Lazy Services Zend\\ServiceManager can use delegator factories to generate \"lazy\" references to your services. Lazy services are proxies that get lazily instantiated, and keep a reference to the real instance of the proxied service. Use cases You may want to lazily initialize a service when it is instantiated very often, but not always used. A typical example is a database connection: it is a dependency to many other elements in your application, but that doesn't mean that every request will execute queries through it. Additionally, instantiating a connection to the database may require some time and eat up resources. Proxying the database connection would allow you to delay that overhead until the object is really needed. Setup Zend\\ServiceManager\\Proxy\\LazyServiceFactory is a delegator factory capable of generating lazy loading proxies for your services. The lazy service facilities depend on ProxyManager ; you will need to install that package before using the feature: $ composer require ocramius/proxy-manager Practical example To demonstrate how a lazy service works, you may use the following Buzzer example class, which is designed to be slow at instantiation time for demonstration purposes: namespace MyApp; class Buzzer { public function __construct() { // deliberately halting the application for 5 seconds sleep(5); } public function buzz() { return 'Buzz!'; } } You can then proceed and configure the service manager to generate proxies instead of real services: use MyApp\\Buzzer; use Zend\\ServiceManager\\Factory\\InvokableFactory; use Zend\\ServiceManager\\Proxy\\LazyServiceFactory; use Zend\\ServiceManager\\ServiceManager; $serviceManager = new \\Zend\\ServiceManager\\ServiceManager([ 'factories' => [ Buzzer::class => InvokableFactory::class, ], 'lazy_services' => [ // Mapping services to their class names is required // since the ServiceManager is not a declarative DIC. 'class_map' => [ Buzzer::class => Buzzer::class, ], ], 'delegators' => [ Buzzer::class => [ LazyServiceFactory::class, ], ], ]); This configuration tells the service manager to add the add LazyServiceFactory as a delegator for Buzzer . You can now retrieve the buzzer: use MyApp\\Buzzer; $buzzer = $serviceManager->get(Buzzer::class); echo $buzzer->buzz(); To verify that the proxying occurred correctly, you can run the following code, which should delay the 5 seconds wait time hardcoded in Buzzer::__construct until Buzzer::buzz is invoked: use MyApp\\Buzzer; for ($i = 0; $i < 100; $i += 1) { $buzzer = $serviceManager->get(Buzzer::class); echo \"created buzzer $i\\n\"; } echo $buzzer->buzz(); Configuration This is the config structure expected by Zend\\ServiceManager\\Proxy\\LazyServiceFactory , in the lazy_services key passed in the service manager configuration: [ // map of service names and their relative class names - this // is required since the service manager cannot know the // class name of defined services up front 'class_map' => [ // 'foo' => 'MyApplication\\Foo', ], // directory where proxy classes will be written - default to system_get_tmp_dir() 'proxies_target_dir' => null, // namespace of the generated proxies, default to \"ProxyManagerGeneratedProxy\" 'proxies_namespace' => null, // whether the generated proxy classes should be written to disk or generated on-the-fly 'write_proxy_files' => false, ]; After you have an instance, you can map lazy service/class pairs using mapLazyService() : $container->mapLazyService('foo', \\MyApplication\\Foo::class);","title":"Lazy services"},{"location":"lazy-services/#lazy-services","text":"Zend\\ServiceManager can use delegator factories to generate \"lazy\" references to your services. Lazy services are proxies that get lazily instantiated, and keep a reference to the real instance of the proxied service.","title":"Lazy Services"},{"location":"lazy-services/#use-cases","text":"You may want to lazily initialize a service when it is instantiated very often, but not always used. A typical example is a database connection: it is a dependency to many other elements in your application, but that doesn't mean that every request will execute queries through it. Additionally, instantiating a connection to the database may require some time and eat up resources. Proxying the database connection would allow you to delay that overhead until the object is really needed.","title":"Use cases"},{"location":"lazy-services/#setup","text":"Zend\\ServiceManager\\Proxy\\LazyServiceFactory is a delegator factory capable of generating lazy loading proxies for your services. The lazy service facilities depend on ProxyManager ; you will need to install that package before using the feature: $ composer require ocramius/proxy-manager","title":"Setup"},{"location":"lazy-services/#practical-example","text":"To demonstrate how a lazy service works, you may use the following Buzzer example class, which is designed to be slow at instantiation time for demonstration purposes: namespace MyApp; class Buzzer { public function __construct() { // deliberately halting the application for 5 seconds sleep(5); } public function buzz() { return 'Buzz!'; } } You can then proceed and configure the service manager to generate proxies instead of real services: use MyApp\\Buzzer; use Zend\\ServiceManager\\Factory\\InvokableFactory; use Zend\\ServiceManager\\Proxy\\LazyServiceFactory; use Zend\\ServiceManager\\ServiceManager; $serviceManager = new \\Zend\\ServiceManager\\ServiceManager([ 'factories' => [ Buzzer::class => InvokableFactory::class, ], 'lazy_services' => [ // Mapping services to their class names is required // since the ServiceManager is not a declarative DIC. 'class_map' => [ Buzzer::class => Buzzer::class, ], ], 'delegators' => [ Buzzer::class => [ LazyServiceFactory::class, ], ], ]); This configuration tells the service manager to add the add LazyServiceFactory as a delegator for Buzzer . You can now retrieve the buzzer: use MyApp\\Buzzer; $buzzer = $serviceManager->get(Buzzer::class); echo $buzzer->buzz(); To verify that the proxying occurred correctly, you can run the following code, which should delay the 5 seconds wait time hardcoded in Buzzer::__construct until Buzzer::buzz is invoked: use MyApp\\Buzzer; for ($i = 0; $i < 100; $i += 1) { $buzzer = $serviceManager->get(Buzzer::class); echo \"created buzzer $i\\n\"; } echo $buzzer->buzz();","title":"Practical example"},{"location":"lazy-services/#configuration","text":"This is the config structure expected by Zend\\ServiceManager\\Proxy\\LazyServiceFactory , in the lazy_services key passed in the service manager configuration: [ // map of service names and their relative class names - this // is required since the service manager cannot know the // class name of defined services up front 'class_map' => [ // 'foo' => 'MyApplication\\Foo', ], // directory where proxy classes will be written - default to system_get_tmp_dir() 'proxies_target_dir' => null, // namespace of the generated proxies, default to \"ProxyManagerGeneratedProxy\" 'proxies_namespace' => null, // whether the generated proxy classes should be written to disk or generated on-the-fly 'write_proxy_files' => false, ]; After you have an instance, you can map lazy service/class pairs using mapLazyService() : $container->mapLazyService('foo', \\MyApplication\\Foo::class);","title":"Configuration"},{"location":"migration/","text":"Migration Guide The Service Manager was first introduced for Zend Framework 2.0.0. Its API remained the same throughout that version. Version 3 is the first new major release of the Service Manager, and contains a number of backwards compatibility breaks. These were introduced to provide better performance and stability. Case Sensitivity and Normalization v2 normalized service names as follows: It stripped non alphanumeric characters. It lowercased the resulting string. This was done to help prevent typographical errors from creating configuration errors. However, it also presented a large performance hit, and led to some unexpected behaviors. In v3, service names are case sensitive, and are not normalized in any way. As such, you must refer to services using the same case in which they were registered. Configuration A number of changes have been made to configuration of service and plugin managers: Minor changes in configuration arrays may impact your usage. ConfigInterface implementations and consumers will need updating. Configuration arrays Configuration for v2 consisted of the following: [ 'services' => [ // service name => instance pairs ], 'aliases' => [ // alias => service name pairs ], 'invokables' => [ // service name => class name pairs ], 'factories' => [ // service name => factory pairs ], 'abstract_factories' => [ // abstract factories ], 'initializers' => [ // initializers ], 'delegators' => [ // service name => [ delegator factories ] ], 'shared' => [ // service name => boolean ], 'share_by_default' => boolean, ] In v3, the configuration remains the same, with the following additions: [ 'lazy_services' => [ // The class_map is required if using lazy services: 'class_map' => [ // service name => class name pairs ], // The following are optional: 'proxies_namespace' => 'Alternate namespace to use for generated proxy classes', 'proxies_target_dir' => 'path in which to write generated proxy classes', 'write_proxy_files' => true, // boolean; false by default ], ] The main change is the addition of integrated lazy service configuration is now integrated. ConfigInterface The principal change to the ConfigInterface is the addition of the toArray() method. This method is intended to return a configuration array in the format listed above, for passing to either the constructor or the configure() method of the ServiceManager .. Config class Zend\\ServiceManager\\Config has been updated to follow the changes to the ConfigInterface and ServiceManager . This essentially means that it removes the various getter methods, and adds the toArray() method. Invokables Invokables no longer exist, at least, not identically to how they existed in ZF2. Internally, ServiceManager now does the following for invokables entries: If the name and value match, it creates a factories entry mapping the service name to Zend\\ServiceManager\\Factory\\InvokableFactory . If the name and value do not match, it creates an aliases entry mapping the service name to the class name, and a factories entry mapping the class name to Zend\\ServiceManager\\Factory\\InvokableFactory . This means that you can use your existing invokables configuration from version 2 in version 3. However, we recommend starting to update your configuration to remove invokables entries in favor of factories (and aliases, if needed). Invokables and plugin managers If you are creating a plugin manager and in-lining invokables into the class definition, you will need to make some changes. $invokableClasses will need to become $factories entries, and you will potentially need to add $aliases entries. As an example, consider the following, from zend-math v2.x: $$$$FENCED_CODE_BLOCK_5db2102c122d24.80234996 Because we no longer define an $invokableClasses property, for v3.x, this now becomes: $$$$FENCED_CODE_BLOCK_5db2102c1233e5.65718455 Lazy Services In v2, if you wanted to create a lazy service, you needed to take the following steps: Ensure you have a config service, with a lazy_services key that contained the configuration necessary for the LazyServiceFactory . Assign the LazyServiceFactoryFactory as a factory for the LazyServiceFactory Assign the LazyServiceFactory as a delegator factory for your service. As an example: use Zend\\ServiceManager\\Proxy\\LazyServiceFactoryFactory; $config = [ 'lazy_services' => [ 'class_map' => [ 'MyClass' => 'MyClass', ], 'proxies_namespace' => 'TestAssetProxy', 'proxies_target_dir' => 'data/proxies/', 'write_proxy_files' => true, ], ]; return [ 'services' => [ 'config' => $config, ], 'invokables' => [ 'MyClass' => 'MyClass', ], 'factories' => [ 'LazyServiceFactory' => LazyServiceFactoryFactory::class, ], 'delegators' => [ 'MyClass' => [ 'LazyServiceFactory', ], ], ]; This was done in part because lazy services were introduced later in the v2 cycle, and not fully integrated in order to retain the API. In order to reduce the number of dependencies and steps necessary to configure lazy services, the following changes were made for v3: Lazy service configuration can now be passed directly to the service manager; it is no longer dependent on a config service. The ServiceManager itself is now responsible for creating the LazyServiceFactory delegator factory, based on the configuration present. The above example becomes the following in v3: use Zend\\ServiceManager\\Factory\\InvokableFactory; use Zend\\ServiceManager\\Proxy\\LazyServiceFactory; return [ 'factories' => [ 'MyClass' => InvokableFactory::class, ], 'delegators' => [ 'MyClass' => [ LazyServiceFactory::class, ], ], 'lazy_services' => [ 'class_map' => [ 'MyClass' => 'MyClass', ], 'proxies_namespace' => 'TestAssetProxy', 'proxies_target_dir' => 'data/proxies/', 'write_proxy_files' => true, ], ]; Additionally, assuming you have configured lazy services initially with the proxy namespace, target directory, etc., you can map lazy services using the new method mapLazyService($name, $class) : $container->mapLazyService('MyClass', 'MyClass'); // or, more simply: $container->mapLazyService('MyClass'); ServiceLocatorInterface Changes The ServiceLocatorInterface now extends the container-interop interface ContainerInterface , which defines the same get() and has() methods as were previously defined. Additionally, it adds a new method: public function build($name, array $options = null) This method is defined to always return a new instance of the requested service, and to allow using the provided $options when creating the instance. ServiceManager API Changes Zend\\ServiceManager\\ServiceManager remains the primary interface with which developers will interact. It has the following changes in v3: It adds a new method, configure() , which allows configuring all instance generation capabilities (aliases, factories, abstract factories, etc.) at once. Peering capabilities were removed. Exceptions are always thrown when service instance creation fails or produces an error; you can no longer disable this. Configuration no longer requires a Zend\\ServiceManager\\Config instance. Config can be used, but is not needed. It adds a new method, build() , for creating discrete service instances. Methods Removed The following methods are removed in v3: setShareByDefault() / shareByDefault() ; this can be passed during instantiation or via configure() . setThrowExceptionInCreate() / getThrowExceptionInCreate() ; exceptions are always thrown when errors are encountered during service instance creation. setRetrieveFromPeeringManagerFirst() / retrieveFromPeeringManagerFirst() ; peering is no longer supported. Constructor The constructor now accepts an array of service configuration, not a Zend\\ServiceManager\\Config instance. Use build() for discrete instances The new method build() acts as a factory method for configured services, and will always return a new instance, never a shared one. Additionally, it provides factory capabilities; you may pass an additional, optional argument, $options , which should be an array of additional options a factory may use to create a new instance. This is primarily of interest when creating plugin managers (more on plugin managers below), which may pass that information on in order to create discrete plugin instances with specific state. As examples: use Zend\\Validator\\Between; $between = $container->build(Between::class, [ 'min' => 5, 'max' => 10, 'inclusive' => true, ]); $alsoBetween = $container->build(Between::class, [ 'min' => 0, 'max' => 100, 'inclusive' => false, ]); The above two validators would be different instances, with their own configuration. Factories Internally, the ServiceManager now only uses the new factory interfaces defined in the Zend\\ServiceManager\\Factory namespace. These replace the interfaces defined in version 2, and define completely new signatures. For migration purposes, all original interfaces were retained, and now inherit from the new interfaces. This provides a migration path; you can add the methods defined in the new interfaces to your existing factories targeting v2, and safely upgrade. (Typically, you will then have the version 2 methods proxy to those defined in version 3.) Interfaces and relations to version 2 Version 2 Interface Version 3 Interface Zend\\ServiceManager\\AbstractFactoryInterface Zend\\ServiceManager\\Factory\\AbstractFactoryInterface Zend\\ServiceManager\\DelegatorFactoryInterface Zend\\ServiceManager\\Factory\\DelegatorFactoryInterface Zend\\ServiceManager\\FactoryInterface Zend\\ServiceManager\\Factory\\FactoryInterface The version 2 interfaces now extend those in version 3, but are marked deprecated . You can continue to use them, but will be required to update your code to use the new interfaces in the future. AbstractFactoryInterface The previous signature of the AbstractFactoryInterface was: interface AbstractFactoryInterface { /** * Determine if we can create a service with name * * @param ServiceLocatorInterface $serviceLocator * @param $name * @param $requestedName * @return bool */ public function canCreateServiceWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName); /** * Create service with name * * @param ServiceLocatorInterface $serviceLocator * @param $name * @param $requestedName * @return mixed */ public function createServiceWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName); } The new signature is: interface AbstractFactoryInterface extends FactoryInterface { /** * Does the factory have a way to create an instance for the service? * * @param ContainerInterface $container * @param string $requestedName * @return bool */ public function canCreate(ContainerInterface $container, $requestedName); } Note that it now extends the FactoryInterface (detailed below), and thus the factory logic has the same signature. In v2, the abstract factory defined the method canCreateServiceWithName() ; in v3, this is renamed to canCreate() , and the method also now receives only two arguments, the container and the requested service name. To prepare your version 2 implementation to work upon upgrade to version 3: Add the methods canCreate() and __invoke() as defined in version 3. Modify your existing canCreateServiceWithName() method to proxy to canCreate() Modify your existing createServiceWithName() method to proxy to __invoke() As an example, given the following implementation from version 2: use Zend\\ServiceManager\\AbstractFactoryInterface; use Zend\\ServiceManager\\ServiceLocatorInterface; class LenientAbstractFactory implements AbstractFactoryInterface { public function canCreateServiceWithName(ServiceLocatorInterface $services, $name, $requestedName) { return class_exists($requestedName); } public function createServiceWithName(ServiceLocatorInterface $services, $name, $requestedName) { return new $requestedName(); } } To update this for version 3 compatibility, you will add the methods canCreate() and __invoke() , move the code from the existing methods into them, and update the existing methods to proxy to the new methods: use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\AbstractFactoryInterface; use Zend\\ServiceManager\\ServiceLocatorInterface; class LenientAbstractFactory implements AbstractFactoryInterface { public function canCreate(ContainerInterface $container, $requestedName) { return class_exists($requestedName); } public function canCreateServiceWithName(ServiceLocatorInterface $services, $name, $requestedName) { return $this->canCreate($services, $requestedName); } public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { return new $requestedName(); } public function createServiceWithName(ServiceLocatorInterface $services, $name, $requestedName) { return $this($services, $requestedName); } } After you have upgraded to version 3, you can take the following steps to remove the migration artifacts: Update your class to implement the new interface. Remove the canCreateServiceWithName() and createServiceWithName() methods from your implementation. From our example above, we would update the class to read as follows: use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\Factory\\AbstractFactoryInterface; // <-- note the change! class LenientAbstractFactory implements AbstractFactoryInterface { public function canCreate(ContainerInterface $container, $requestedName) { return class_exists($requestedName); } public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { return new $requestedName(); } } DelegatorFactoryInterface The previous signature of the DelegatorFactoryInterface was: interface DelegatorFactoryInterface { /** * A factory that creates delegates of a given service * * @param ServiceLocatorInterface $serviceLocator the service locator which requested the service * @param string $name the normalized service name * @param string $requestedName the requested service name * @param callable $callback the callback that is responsible for creating the service * * @return mixed */ public function createDelegatorWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName, $callback); } The new signature is: interface DelegatorFactoryInterface { /** * A factory that creates delegates of a given service * * @param ContainerInterface $container * @param string $name * @param callable $callback * @param null|array $options * @return object */ public function __invoke(ContainerInterface $container, $name, callable $callback, array $options = null); } Note that the $name and $requestedName arguments are now merged into a single $name argument, and that the factory now allows passing additional options to use (typically as passed via build() ). To prepare your existing delegator factories for version 3, take the following steps: Implement the __invoke() method in your existing factory, copying the code from your existing createDelegatorWithName() method into it. Modify the createDelegatorWithName() method to proxy to the new method. Consider the following delegator factory that works for version 2: use Zend\\ServiceManager\\DelegatorFactoryInterface; use Zend\\ServiceManager\\ServiceLocatorInterface; class ObserverAttachmentDelegator implements DelegatorFactoryInterface { public function createDelegatorWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName, $callback) { $subject = $callback(); $subject->attach($serviceLocator->get(Observer::class); return $subject; } } To prepare this for version 3, we'd implement the __invoke() signature from version 3, and modify createDelegatorWithName() to proxy to it: use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\DelegatorFactoryInterface; use Zend\\ServiceManager\\ServiceLocatorInterface; class ObserverAttachmentDelegator implements DelegatorFactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, callable $callback, array $options = null) { $subject = $callback(); $subject->attach($container->get(Observer::class); return $subject; } public function createDelegatorWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName, $callback) { return $this($serviceLocator, $requestedName, $callback); } } After you have upgraded to version 3, you can take the following steps to remove the migration artifacts: Update your class to implement the new interface. Remove the createDelegatorWithName() method from your implementation. From our example above, we would update the class to read as follows: use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\Factory\\DelegatorFactoryInterface; // <-- note the change! class ObserverAttachmentDelegator implements DelegatorFactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, callable $callback, array $options = null) { $subject = $callback(); $subject->attach($container->get(Observer::class); return $subject; } } FactoryInterface The previous signature of the FactoryInterface was: interface FactoryInterface { /** * Create service * * @param ServiceLocatorInterface $serviceLocator * @return mixed */ public function createService(ServiceLocatorInterface $serviceLocator); } The new signature is: interface FactoryInterface { /** * Create an object * * @param ContainerInterface $container * @param string $requestedName * @param null|array $options * @return object */ public function __invoke(ContainerInterface $container, $requestedName, array $options = null); } Note that the factory now accepts an additional required argument, $requestedName ; v2 already passed this argument, but it was not specified in the interface itself. Additionally, a third optional argument, $options , allows you to provide $options to the ServiceManager::build() method; factories can then take these into account when creating an instance. Because factories now can expect to receive the service name, they may be re-used for multiple services, largely replacing abstract factories in version 3. To prepare your existing factories for version 3, take the following steps: Implement the __invoke() method in your existing factory, copying the code from your existing createService() method into it. Modify the createService() method to proxy to the new method. Consider the following factory that works for version 2: use Zend\\ServiceManager\\FactoryInterface; use Zend\\ServiceManager\\ServiceLocatorInterface; class FooFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $services) { return new Foo($services->get(Bar::class)); } } To prepare this for version 3, we'd implement the __invoke() signature from version 3, and modify createService() to proxy to it: use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\FactoryInterface; use Zend\\ServiceManager\\ServiceLocatorInterface; class FooFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { return new Foo($container->get(Bar::class)); } public function createService(ServiceLocatorInterface $services) { return $this($services, Foo::class); } } Note that the call to $this() adds a new argument; since your factory isn't using the $requestedName , this can be anything, but must be passed to prevent a fatal exception due to a missing argument. In this case, we chose to pass the name of the class the factory is creating. After you have upgraded to version 3, you can take the following steps to remove the migration artifacts: Update your class to implement the new interface. Remove the createService() method from your implementation. From our example above, we would update the class to read as follows: use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\Factory\\FactoryInterface; // <-- note the change! class FooFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { return new Foo($container->get(Bar::class)); } } Many factories already work with v3! Within the skeleton application, tutorial, and even in commonly shipped modules such as those in Apigility, we have typically suggested building your factories as invokable classes. If you were doing this already, your factories will already work with version 3! Version 2 factories can accept the requested name already Since 2.2, factories have been passed two additional parameters, the \"canonical\" name (a mis-nomer, as it is actually the normalized name), and the \"requested\" name (the actual string passed to get() ). As such, you can already write factories that accept the requested name, and have them change behavior based on that information! New InvokableFactory Class Zend\\ServiceManager\\Factory\\InvokableFactory is a new FactoryInterface implementation that provides the capabilities of the \"invokable classes\" present in version 2. It essentially instantiates and returns the requested class name; if $options is non-empty, it passes them directly to the constructor. This class was added to the version 2 tree to allow developers to start using it when preparing their code for version 3. This is particularly of interest when creating plugin managers, as you'll typically want the internal configuration to only include factories and aliases. Initializers Initializers are still present in the Service Manager component, but exist primarily for backwards compatibility; we recommend using delegator factories for setter and interface injection instead of initializers, as those will be run per-service, versus for all services. For migration purposes, the original interface was retained, and now inherits from the new interface. This provides a migration path; you can add the method defined in the new interface to your existing initializers targeting v2, and safely upgrade. (Typically, you will then have the version 2 method proxy to the one defined in version 3.) The following changes were made to initializers: Zend\\ServiceManager\\InitializerInterface was renamed to Zend\\ServiceManager\\Initializer\\InitializerInterface . The interface itself has a new signature. The previous signature was: public function initialize($instance, ServiceLocatorInterface $serviceLocator) It is now: public function __invoke(ContainerInterface $container, $instance) The changes were made to ensure the signature is internally consistent with the various factories. To prepare your existing initializers for version 3, take the following steps: Implement the __invoke() method in your existing factory, copying the code from your existing initialize() method into it. Modify the initialize() method to proxy to the new method. As an example, consider this initializer for version 2: use Zend\\ServiceManager\\InitializerInterface; use Zend\\ServiceManager\\ServiceLocatorInterface; class FooInitializer implements InitializerInterface { public function initializer($instance, ServiceLocatorInterface $services) { if (! $instance implements FooAwareInterface) { return $instance; } $instance->setFoo($services->get(FooInterface::class); return $instance; } } To prepare this for version 3, we'd implement the __invoke() signature from version 3, and modify initialize() to proxy to it: use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\InitializerInterface; use Zend\\ServiceManager\\ServiceLocatorInterface; class FooInitializer implements InitializerInterface { public function __invoke(ContainerInterface $container, $instance) { if (! $instance implements FooAwareInterface) { return $instance; } $container->setFoo($services->get(FooInterface::class); return $instance; } public function initializer($instance, ServiceLocatorInterface $services) { return $this($services, $instance); } } After you have upgraded to version 3, you can take the following steps to remove the migration artifacts: Update your class to implement the new interface. Remove the initialize() method from your implementation. From our example above, we would update the class to read as follows: use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\Initializer\\InitializerInterface; // <-- note the change! class FooInitializer implements InitializerInterface { public function __invoke(ContainerInterface $container, $instance) { if (! $instance implements FooAwareInterface) { return $instance; } $container->setFoo($services->get(FooInterface::class); return $instance; } } Update your callables! Version 2 allows you to provide initializers as PHP callables. However, this means that the signature of those callables is incorrect for version 3! To make your code forwards compatible, you have two paths: The first is to simply provide an InitializerInterface implementation instead. This guarantees that the correct method is called based on the version of the ServiceManager in use. The second approach is to omit typehints on the arguments, and do typechecks internally. As an example, let's say you have the following: $$$$FENCED_CODE_BLOCK_5db2102c123665.66153448 To make this future-proof, remove the typehints, and check the types within the callable: $$$$FENCED_CODE_BLOCK_5db2102c123888.38432849 This approach can also be done if you omitted typehints in the first place. Regardless, the important part to remember is that order of arguments is inverted between the two versions. Plugin Managers In version 2, plugin managers were ServiceManager instances that implemented both the MutableCreationOptionsInterface and ServiceLocatorAwareInterface , and extended AbstractPluginManager . Plugin managers passed themselves to factories, abstract factories, etc., requiring pulling the parent service manager, if composed, in order to resolve application-level dependencies. In version 3, we define the following: Zend\\ServiceManager\\PluginManagerInterface , which provides the public API differences from the ServiceLocatorInterface . Zend\\ServiceManager\\AbstractPluginManager , which gives the basic capabilities for plugin managers. The class now has a (semi) required dependency on the application-level service manager instance, which is passed to all factories, abstract factories, etc. (More on this below.) PluginManagerInterface Zend\\ServiceManager\\PluginInterface is a new interface for version 3, extending ServiceLocatorInterface and adding one method: /** * Validate an instance * * @param object $instance * @return void * @throws InvalidServiceException If created instance does not respect the * constraint on type imposed by the plugin manager */ public function validate($instance); All plugin managers must implement this interface. For backwards-compatibility purposes, AbstractPluginManager will check for the validatePlugin() method (defined as abstract in v2), and, on discovery, trigger an E_USER_DEPRECATED notice, followed by invocation of that method. AbstractPluginManager As it did in version 2, AbstractPluginManager extends ServiceManager . That means that all changes made to the ServiceManager for v3 also apply to the AbstractPluginManager . In addition, review the following changes. Constructor The constructor now accepts the following arguments, in the following order: The parent container instance; this is usually the application-level ServiceManager instance. Optionally, an array of configuration for the plugin manager instance; this should have the same format as for a ServiceManager instance. validatePlugin() was renamed to validate() (now defined in PluginManagerInterface ). The AbstractPluginManager provides a basic implementation (detailed below). The signature of get() changes (more below). For backwards compatibility purposes, the constructor also allows the following for the initial argument: A null value. In this case, the plugin manager will use itself as the creation context, but also raise a deprecation notice indicating a container should be passed instead. You can pass the parent container to the setServiceLocator() method to reset the creation context, but, again, this raises a deprecation notice. A ConfigInterface instance. In this case, the plugin manager will call the config instance's toArray() method to cast it to an array, and use the return value as the configuration to pass to the parent constructor. As with the null value, the plugin manager will be set as its own creation context. Validation The validate() method is defined as follows: public function validate($instance) { if (method_exists($this, 'validatePlugin')) { trigger_error(sprintf( '%s::validatePlugin() has been deprecated as of 3.0; please define validate() instead', get_class($this) ), E_USER_DEPRECATED); $this->validatePlugin($instance); return; } if (empty($this->instanceOf) || $instance instanceof $this->instanceOf) { return; } throw new InvalidServiceException(sprintf( 'Plugin manager \"%s\" expected an instance of type \"%s\", but \"%s\" was received', __CLASS__, $this->instanceOf, is_object($instance) ? get_class($instance) : gettype($instance) )); } The two takeaways from this are: If you are upgrading from v2, your code should continue to work, but will emit a deprecation notice . The way to remove the deprecation notice is to rename the validatePlugin() method to validate() , or to remove it and define the $instanceOf property (if all you're doing is checking the plugin against a single typehint). Most plugin manager instances can simply define the $instanceOf property to indicate what plugin interface is considered valid for the plugin manager, and make no further changes to the abstract plugin manager: protected $instanceOf = ValidatorInterface::class; get() The get() signature changes from: public function get($name, $options = [], $usePeeringServiceManagers = true) to: public function get($name, array $options = null) Essentially: $options now must be an array if passed, and peering is no longer supported. Deprecated methods Finally, the following methods from v2's ServiceLocatorAwareInterface are retained (without implementing the interface), but marked as deprecated: setServiceLocator() . This method exists as many tests and plugin manager factories were using it to inject the parent locator (now called the creation context). This method may still be used, and will now set the creation context for the plugin manager, but also emit a deprecation warning. getServiceLocator() is implemented in ServiceManager (from which AbstractPluginManager inherits), but marked as deprecated. Regarding this latter point, getServiceLocator() exists to provide backwards compatibility for existing plugin factories . These factories typically pull dependencies from the parent/application container in order to initialize the plugin. In v2, this would look like: function ($plugins) { $services = $plugins->getServiceLocator(); // pull dependencies from $services: $foo = $services->get('Foo'); $bar = $services->get('Bar'); return new Plugin($foo, $bar); } In v3, the initial argument to the factory is not the plugin manager instance, but the creation context , which is analogous to the parent locator in v2. In order to preserve existing behavior, we added the getServiceLocator() method to the ServiceManager . As such, the above will continue to work in v3. However, this method is marked as deprecated, and will emit an E_USER_DEPRECATED notice. To remove the notice, you will need to upgrade your code. The above example thus becomes: function ($services) { // pull dependencies from $services: $foo = $services->get('Foo'); $bar = $services->get('Bar'); return new Plugin($foo, $bar); } If you were using the passed plugin manager and pulling other plugins, you will need to update your code to retrieve the plugin manager from the passed container. As an example, given this: function ($plugins) { $anotherPlugin = $plugins->get('AnotherPlugin'); return new Plugin($anotherPlugin); } You will need to rewrite it to: function ($services) { $plugins = $services->get('PluginManager'); $anotherPlugin = $plugins->get('AnotherPlugin'); return new Plugin($anotherPlugin); } Plugin Service Creation The get() method has new behavior: When non-empty $options are passed, it always delegates to build() , and thus will always return a new instance . If you are using $options , the assumption is that you are using the plugin manager as a factory, and thus the instance should not be cached. Without $options , get() will cache by default (the default behavior of ServiceManager ). To never cache instances, either set the $sharedByDefault class property to false , or pass a boolean false value via the shared_by_default configuration key. Migration example Let's consider the following plugin manager geared towards version 2: use RuntimeException; use Zend\\ServiceManager\\AbstractPluginManager; class ObserverPluginManager extends AbstractPluginManager { protected $invokables = [ 'mail' => MailObserver::class, 'log' => LogObserver::class, ]; protected $shareByDefault = false; public function validatePlugin($instance) { if (! $instance instanceof ObserverInterface) { throw new RuntimeException(sprintf( 'Invalid plugin \"%s\" created; not an instance of %s', get_class($instance), ObserverInterface::class )); } } } To prepare this for version 3, we need to do the following: We need to change the $invokables configuration to a combination of factories and aliases . We need to implement a validate() method. We need to update the validatePlugin() method to proxy to validate() . We need to add a $sharedByDefault property (if $shareByDefault is present). Doing so, we get the following result: namespace MyNamespace; use RuntimeException; use Zend\\ServiceManager\\AbstractPluginManager; use Zend\\ServiceManager\\Exception\\InvalidServiceException; use Zend\\ServiceManager\\Factory\\InvokableFactory; class ObserverPluginManager extends AbstractPluginManager { protected $instanceOf = ObserverInterface::class; protected $aliases = [ 'mail' => MailObserver::class, 'Mail' => MailObserver::class, 'log' => LogObserver::class, 'Log' => LogObserver::class, ]; protected $factories = [ MailObserver::class => InvokableFactory::class, LogObserver::class => InvokableFactory::class, // Legacy (v2) due to alias resolution 'mynamespacemailobserver' => InvokableFactory::class, 'mynamespacelogobserver' => InvokableFactory::class, ]; protected $shareByDefault = false; protected $sharedByDefault = false; public function validate($instance) { if (! $instance instanceof $this->instanceOf) { throw new InvalidServiceException(sprintf( 'Invalid plugin \"%s\" created; not an instance of %s', get_class($instance), $this->instanceOf )); } } public function validatePlugin($instance) { try { $this->validate($instance); } catch (InvalidServiceException $e) { throw new RuntimeException($e->getMessage(), $e->getCode(), $e); } } } Things to note about the above: It introduces a new property, $instanceOf . We'll use this later, when we're ready to clean up post-migration. It introduces four aliases. This is to allow fetching the various plugins as any of mail , Mail , log , or Log \u2014 all of which are valid in version 2, but, because version 3 does not normalize names, need to be explicitly aliased. The aliases point to the fully qualified class name (FQCN) for the service being generated, and these are mapped to InvokableFactory instances. This means you can also fetch your plugins by their FQCN. There are also factory entries for the canonicalized FQCN of each factory, which will be used in v2. (Canonicalization in v2 strips non-alphanumeric characters, and casts to lowercase.) validatePlugin() continues to throw the old exception The above will now work in both version 2 and version 3. Migration testing To test your changes, create a new MigrationTest case that uses Zend\\ServiceManager\\Test\\CommonPluginManagerTrait . Override getPluginManager() to return an instance of your plugin manager, and override getV2InvalidPluginException() to return the classname of the exception your validatePlugin() method throws: use MyNamespace\\ObserverInterface; use MyNamespace\\ObserverPluginManager; use MyNamespace\\Exception\\RuntimeException; use PHPUnit_Framework_TestCase as TestCase; use Zend\\ServiceManager\\ServiceManager; use Zend\\ServiceManager\\Test\\CommonPluginManagerTrait; class MigrationTest extends TestCase { use CommonPluginManagerTrait; protected function getPluginManager() { return new ObserverPluginManager(new ServiceManager()); } protected function getV2InvalidPluginException() { return RuntimeException::class; } protected function getInstanceOf() { return ObserverInterface::class; } } This will check that: You have set the $instanceOf property. $shareByDefault and $sharedByDefault match, if present. That requesting an invalid plugin throws the right exception. That all your aliases resolve. Post migration After you migrate to version 3, you can clean up your plugin manager: Remove the validatePlugin() method. If your validate() routine is only checking that the instance is of a single type, and has no other logic, you can remove that implementation as well, as the AbstractPluginManager already takes care of that when $instanceOf is defined! Remove the canonicalized FQCN entry for each factory Performing these steps on the above, we get: use Zend\\ServiceManager\\AbstractPluginManager; use Zend\\ServiceManager\\Factory\\InvokableFactory; class ObserverPluginManager extends AbstractPluginManager { protected $instanceOf = ObserverInterface::class; protected $aliases = [ 'mail' => MailObserver::class, 'Mail' => MailObserver::class, 'log' => LogObserver::class, 'Log' => LogObserver::class, ]; protected $factories = [ MailObserver::class => InvokableFactory::class, LogObserver::class => InvokableFactory::class, ]; } DI Namespace The Zend\\ServiceManager\\Di namespace has been removed. The Zend\\Di component is not actively maintained, and has been largely deprecated during the ZF2 lifecycle in favor of the Service Manager. Its usage as an abstract factory is problematic and error prone when used in conjunction with the Service Manager; as such, we've removed it for the initial v3 release. We may re-introduce it via a separate component in the future. Miscellaneous Interfaces, Traits, and Classes The following interfaces, traits, and classes were removed : Zend\\ServiceManager\\MutableCreationOptionsInterface ; this was previously used by the AbstractPluginManager , and is no longer required as we ship a separate PluginManagerInterface , and because the functionality is encompassed by the build() method. Zend\\ServiceManager\\MutableCreationOptionsTrait Zend\\ServiceManager\\Proxy\\LazyServiceFactoryFactory ; its capabilities were moved directly into the ServiceManager . Zend\\ServiceManager\\ServiceLocatorAwareInterface Zend\\ServiceManager\\ServiceLocatorAwareTrait Zend\\ServiceManager\\ServiceManagerAwareInterface The ServiceLocatorAware and ServiceManagerAware interfaces and traits were too often abused under v2, and represent the antithesis of the purpose of the Service Manager component; dependencies should be directly injected, and the container should never be composed by objects. The following classes and interfaces have changes: Zend\\ServiceManager\\Proxy\\LazyServiceFactory is now marked final , and implements Zend\\ServiceManager\\Proxy\\DelegatorFactoryInterface . Its dependencies and capabilities remain the same. Zend\\ServiceManager\\ConfigInterface now is expected to return the modified ServiceManager instance. Zend\\ServiceManager\\Config was updated to follow the changes to ConfigInterface and ServiceManager , and now returns the updated ServiceManager instance from configureServiceManager() .","title":"Migration Guide"},{"location":"migration/#migration-guide","text":"The Service Manager was first introduced for Zend Framework 2.0.0. Its API remained the same throughout that version. Version 3 is the first new major release of the Service Manager, and contains a number of backwards compatibility breaks. These were introduced to provide better performance and stability.","title":"Migration Guide"},{"location":"migration/#case-sensitivity-and-normalization","text":"v2 normalized service names as follows: It stripped non alphanumeric characters. It lowercased the resulting string. This was done to help prevent typographical errors from creating configuration errors. However, it also presented a large performance hit, and led to some unexpected behaviors. In v3, service names are case sensitive, and are not normalized in any way. As such, you must refer to services using the same case in which they were registered.","title":"Case Sensitivity and Normalization"},{"location":"migration/#configuration","text":"A number of changes have been made to configuration of service and plugin managers: Minor changes in configuration arrays may impact your usage. ConfigInterface implementations and consumers will need updating.","title":"Configuration"},{"location":"migration/#invokables","text":"Invokables no longer exist, at least, not identically to how they existed in ZF2. Internally, ServiceManager now does the following for invokables entries: If the name and value match, it creates a factories entry mapping the service name to Zend\\ServiceManager\\Factory\\InvokableFactory . If the name and value do not match, it creates an aliases entry mapping the service name to the class name, and a factories entry mapping the class name to Zend\\ServiceManager\\Factory\\InvokableFactory . This means that you can use your existing invokables configuration from version 2 in version 3. However, we recommend starting to update your configuration to remove invokables entries in favor of factories (and aliases, if needed).","title":"Invokables"},{"location":"migration/#lazy-services","text":"In v2, if you wanted to create a lazy service, you needed to take the following steps: Ensure you have a config service, with a lazy_services key that contained the configuration necessary for the LazyServiceFactory . Assign the LazyServiceFactoryFactory as a factory for the LazyServiceFactory Assign the LazyServiceFactory as a delegator factory for your service. As an example: use Zend\\ServiceManager\\Proxy\\LazyServiceFactoryFactory; $config = [ 'lazy_services' => [ 'class_map' => [ 'MyClass' => 'MyClass', ], 'proxies_namespace' => 'TestAssetProxy', 'proxies_target_dir' => 'data/proxies/', 'write_proxy_files' => true, ], ]; return [ 'services' => [ 'config' => $config, ], 'invokables' => [ 'MyClass' => 'MyClass', ], 'factories' => [ 'LazyServiceFactory' => LazyServiceFactoryFactory::class, ], 'delegators' => [ 'MyClass' => [ 'LazyServiceFactory', ], ], ]; This was done in part because lazy services were introduced later in the v2 cycle, and not fully integrated in order to retain the API. In order to reduce the number of dependencies and steps necessary to configure lazy services, the following changes were made for v3: Lazy service configuration can now be passed directly to the service manager; it is no longer dependent on a config service. The ServiceManager itself is now responsible for creating the LazyServiceFactory delegator factory, based on the configuration present. The above example becomes the following in v3: use Zend\\ServiceManager\\Factory\\InvokableFactory; use Zend\\ServiceManager\\Proxy\\LazyServiceFactory; return [ 'factories' => [ 'MyClass' => InvokableFactory::class, ], 'delegators' => [ 'MyClass' => [ LazyServiceFactory::class, ], ], 'lazy_services' => [ 'class_map' => [ 'MyClass' => 'MyClass', ], 'proxies_namespace' => 'TestAssetProxy', 'proxies_target_dir' => 'data/proxies/', 'write_proxy_files' => true, ], ]; Additionally, assuming you have configured lazy services initially with the proxy namespace, target directory, etc., you can map lazy services using the new method mapLazyService($name, $class) : $container->mapLazyService('MyClass', 'MyClass'); // or, more simply: $container->mapLazyService('MyClass');","title":"Lazy Services"},{"location":"migration/#servicelocatorinterface-changes","text":"The ServiceLocatorInterface now extends the container-interop interface ContainerInterface , which defines the same get() and has() methods as were previously defined. Additionally, it adds a new method: public function build($name, array $options = null) This method is defined to always return a new instance of the requested service, and to allow using the provided $options when creating the instance.","title":"ServiceLocatorInterface Changes"},{"location":"migration/#servicemanager-api-changes","text":"Zend\\ServiceManager\\ServiceManager remains the primary interface with which developers will interact. It has the following changes in v3: It adds a new method, configure() , which allows configuring all instance generation capabilities (aliases, factories, abstract factories, etc.) at once. Peering capabilities were removed. Exceptions are always thrown when service instance creation fails or produces an error; you can no longer disable this. Configuration no longer requires a Zend\\ServiceManager\\Config instance. Config can be used, but is not needed. It adds a new method, build() , for creating discrete service instances.","title":"ServiceManager API Changes"},{"location":"migration/#factories","text":"Internally, the ServiceManager now only uses the new factory interfaces defined in the Zend\\ServiceManager\\Factory namespace. These replace the interfaces defined in version 2, and define completely new signatures. For migration purposes, all original interfaces were retained, and now inherit from the new interfaces. This provides a migration path; you can add the methods defined in the new interfaces to your existing factories targeting v2, and safely upgrade. (Typically, you will then have the version 2 methods proxy to those defined in version 3.)","title":"Factories"},{"location":"migration/#initializers","text":"Initializers are still present in the Service Manager component, but exist primarily for backwards compatibility; we recommend using delegator factories for setter and interface injection instead of initializers, as those will be run per-service, versus for all services. For migration purposes, the original interface was retained, and now inherits from the new interface. This provides a migration path; you can add the method defined in the new interface to your existing initializers targeting v2, and safely upgrade. (Typically, you will then have the version 2 method proxy to the one defined in version 3.) The following changes were made to initializers: Zend\\ServiceManager\\InitializerInterface was renamed to Zend\\ServiceManager\\Initializer\\InitializerInterface . The interface itself has a new signature. The previous signature was: public function initialize($instance, ServiceLocatorInterface $serviceLocator) It is now: public function __invoke(ContainerInterface $container, $instance) The changes were made to ensure the signature is internally consistent with the various factories. To prepare your existing initializers for version 3, take the following steps: Implement the __invoke() method in your existing factory, copying the code from your existing initialize() method into it. Modify the initialize() method to proxy to the new method. As an example, consider this initializer for version 2: use Zend\\ServiceManager\\InitializerInterface; use Zend\\ServiceManager\\ServiceLocatorInterface; class FooInitializer implements InitializerInterface { public function initializer($instance, ServiceLocatorInterface $services) { if (! $instance implements FooAwareInterface) { return $instance; } $instance->setFoo($services->get(FooInterface::class); return $instance; } } To prepare this for version 3, we'd implement the __invoke() signature from version 3, and modify initialize() to proxy to it: use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\InitializerInterface; use Zend\\ServiceManager\\ServiceLocatorInterface; class FooInitializer implements InitializerInterface { public function __invoke(ContainerInterface $container, $instance) { if (! $instance implements FooAwareInterface) { return $instance; } $container->setFoo($services->get(FooInterface::class); return $instance; } public function initializer($instance, ServiceLocatorInterface $services) { return $this($services, $instance); } } After you have upgraded to version 3, you can take the following steps to remove the migration artifacts: Update your class to implement the new interface. Remove the initialize() method from your implementation. From our example above, we would update the class to read as follows: use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\Initializer\\InitializerInterface; // <-- note the change! class FooInitializer implements InitializerInterface { public function __invoke(ContainerInterface $container, $instance) { if (! $instance implements FooAwareInterface) { return $instance; } $container->setFoo($services->get(FooInterface::class); return $instance; } }","title":"Initializers"},{"location":"migration/#plugin-managers","text":"In version 2, plugin managers were ServiceManager instances that implemented both the MutableCreationOptionsInterface and ServiceLocatorAwareInterface , and extended AbstractPluginManager . Plugin managers passed themselves to factories, abstract factories, etc., requiring pulling the parent service manager, if composed, in order to resolve application-level dependencies. In version 3, we define the following: Zend\\ServiceManager\\PluginManagerInterface , which provides the public API differences from the ServiceLocatorInterface . Zend\\ServiceManager\\AbstractPluginManager , which gives the basic capabilities for plugin managers. The class now has a (semi) required dependency on the application-level service manager instance, which is passed to all factories, abstract factories, etc. (More on this below.)","title":"Plugin Managers"},{"location":"migration/#di-namespace","text":"The Zend\\ServiceManager\\Di namespace has been removed. The Zend\\Di component is not actively maintained, and has been largely deprecated during the ZF2 lifecycle in favor of the Service Manager. Its usage as an abstract factory is problematic and error prone when used in conjunction with the Service Manager; as such, we've removed it for the initial v3 release. We may re-introduce it via a separate component in the future.","title":"DI Namespace"},{"location":"migration/#miscellaneous-interfaces-traits-and-classes","text":"The following interfaces, traits, and classes were removed : Zend\\ServiceManager\\MutableCreationOptionsInterface ; this was previously used by the AbstractPluginManager , and is no longer required as we ship a separate PluginManagerInterface , and because the functionality is encompassed by the build() method. Zend\\ServiceManager\\MutableCreationOptionsTrait Zend\\ServiceManager\\Proxy\\LazyServiceFactoryFactory ; its capabilities were moved directly into the ServiceManager . Zend\\ServiceManager\\ServiceLocatorAwareInterface Zend\\ServiceManager\\ServiceLocatorAwareTrait Zend\\ServiceManager\\ServiceManagerAwareInterface The ServiceLocatorAware and ServiceManagerAware interfaces and traits were too often abused under v2, and represent the antithesis of the purpose of the Service Manager component; dependencies should be directly injected, and the container should never be composed by objects. The following classes and interfaces have changes: Zend\\ServiceManager\\Proxy\\LazyServiceFactory is now marked final , and implements Zend\\ServiceManager\\Proxy\\DelegatorFactoryInterface . Its dependencies and capabilities remain the same. Zend\\ServiceManager\\ConfigInterface now is expected to return the modified ServiceManager instance. Zend\\ServiceManager\\Config was updated to follow the changes to ConfigInterface and ServiceManager , and now returns the updated ServiceManager instance from configureServiceManager() .","title":"Miscellaneous Interfaces, Traits, and Classes"},{"location":"plugin-managers/","text":"Plugin managers Plugin managers are specialized service managers, typically used to create homogeneous objects of a specific type. Because a plugin manager extends a service manager, it works the same and can be configured similarly. It provides a separation of concerns (it will be used in specific contexts), and provides additional instance validation. Zend Framework components extensively use plugin managers to create services that share common functionalities. For instance, all validator services are specified inside a specialized ValidatorPluginManager . Creating a plugin manager To create a plugin manager, you first need to create a new class that extends Zend\\ServiceManager\\AbstractPluginManager : class ValidatorPluginManager extends AbstractPluginManager { protected $instanceOf = ValidatorInterface::class; } The $instanceOf variable specifies a class/interface type that all instances retrieved from the plugin manager must fulfill. If an instance created by the plugin manager does not match, a Zend\\ServiceManager\\Exception\\InvalidServiceException exception will be thrown. Most of the time, this shortcut is enough. However if you have more complex validation rules, you can override the validate() method: class ValidatorPluginManager extends AbstractPluginManager { public function validate($instance) { if ($instance instanceof Foo || $instance instanceof Bar) { return; } throw new InvalidServiceException('This is not a valid service!'); } } Configuring a plugin manager A plugin manager requires that you pass a parent service manager (typically, the application's service manager) as well as service configuration. Service configuration follows the exact same pattern as for a normal service manager; refer to the configuring the service manager section for details. Because a plugin manager is often a service itself, we recommend you to register the plugin manager as part of the general service manager, as shown below: $serviceManager = new ServiceManager([ 'factories' => [ ValidatorPluginManager::class => function(ContainerInterface $container, $requestedName) { return new ValidatorPluginManager($container, [ 'factories' => [ StringLengthValidator::class => InvokableFactory::class, ], ]); }, ], ]); // Get the plugin manager: $pluginManager = $serviceManager->get(ValidatorPluginManager::class); // Use the plugin manager $validator = $pluginManager->get(StringLengthValidator::class); Unlike the version 2 implementation, when inside the context of the factory of a service created by a plugin manager, the passed container will not be the plugin manager, but the parent service manager instead. If you need access to other plugins of the same type, you will need to fetch the plugin manager from the container: $$$$FENCED_CODE_BLOCK_5db2102c128ef7.06458980","title":"Plugin managers"},{"location":"plugin-managers/#plugin-managers","text":"Plugin managers are specialized service managers, typically used to create homogeneous objects of a specific type. Because a plugin manager extends a service manager, it works the same and can be configured similarly. It provides a separation of concerns (it will be used in specific contexts), and provides additional instance validation. Zend Framework components extensively use plugin managers to create services that share common functionalities. For instance, all validator services are specified inside a specialized ValidatorPluginManager .","title":"Plugin managers"},{"location":"plugin-managers/#creating-a-plugin-manager","text":"To create a plugin manager, you first need to create a new class that extends Zend\\ServiceManager\\AbstractPluginManager : class ValidatorPluginManager extends AbstractPluginManager { protected $instanceOf = ValidatorInterface::class; } The $instanceOf variable specifies a class/interface type that all instances retrieved from the plugin manager must fulfill. If an instance created by the plugin manager does not match, a Zend\\ServiceManager\\Exception\\InvalidServiceException exception will be thrown. Most of the time, this shortcut is enough. However if you have more complex validation rules, you can override the validate() method: class ValidatorPluginManager extends AbstractPluginManager { public function validate($instance) { if ($instance instanceof Foo || $instance instanceof Bar) { return; } throw new InvalidServiceException('This is not a valid service!'); } }","title":"Creating a plugin manager"},{"location":"plugin-managers/#configuring-a-plugin-manager","text":"A plugin manager requires that you pass a parent service manager (typically, the application's service manager) as well as service configuration. Service configuration follows the exact same pattern as for a normal service manager; refer to the configuring the service manager section for details. Because a plugin manager is often a service itself, we recommend you to register the plugin manager as part of the general service manager, as shown below: $serviceManager = new ServiceManager([ 'factories' => [ ValidatorPluginManager::class => function(ContainerInterface $container, $requestedName) { return new ValidatorPluginManager($container, [ 'factories' => [ StringLengthValidator::class => InvokableFactory::class, ], ]); }, ], ]); // Get the plugin manager: $pluginManager = $serviceManager->get(ValidatorPluginManager::class); // Use the plugin manager $validator = $pluginManager->get(StringLengthValidator::class); Unlike the version 2 implementation, when inside the context of the factory of a service created by a plugin manager, the passed container will not be the plugin manager, but the parent service manager instead. If you need access to other plugins of the same type, you will need to fetch the plugin manager from the container: $$$$FENCED_CODE_BLOCK_5db2102c128ef7.06458980","title":"Configuring a plugin manager"},{"location":"psr-11/","text":"PSR-11 Support container-interop/container-interop 1.2.0 modifies its codebase to extend interfaces from psr/container (the official interfaces for PSR-11 ). If you are on a pre-3.3.0 version of zend-servicemanager, update your project, and receive container-interop 1.2, then zend-servicemanager can already act as a PSR-11 provider! zend-servicemanager 3.3.0 requires at least version 1.2 of container-interop, and also requires psr/container 1.0 to explicitly signal that it is a PSR-11 provider, and to allow removal of the container-interop dependency later. Version 4.0 will require only psr/container, and will update the various factory interfaces and exception implementations to typehint against the PSR-11 interfaces, which will require changes to any implementations you have. In the meantime, you can duck-type the following factory types: Zend\\ServiceManager\\Factory\\FactoryInterface : use a callable with the following signature: php function ( \\Psr\\Container\\ContainerInterface $container, string $requestedName, array $options = null ) Zend\\ServiceManager\\Factory\\DelegatorFactoryInterface : use a callable with the following signature: php function ( \\Psr\\Container\\ContainerInterface $container, string $name, callable $callback, array $options = null ) Zend\\ServiceManager\\Initializer\\InitializerInterface : use a callable with the following signature: php function ( \\Psr\\Container\\ContainerInterface $container, $instance ) Abstract factories can not be duck typed, due to the additional canCreate() method. You can also leave your factories as-is for now, and update them once zend-servicemanager v4.0 is released, at which time we will be providing tooling to help migrate your factories to PSR-11.","title":"PSR-11 Support"},{"location":"psr-11/#psr-11-support","text":"container-interop/container-interop 1.2.0 modifies its codebase to extend interfaces from psr/container (the official interfaces for PSR-11 ). If you are on a pre-3.3.0 version of zend-servicemanager, update your project, and receive container-interop 1.2, then zend-servicemanager can already act as a PSR-11 provider! zend-servicemanager 3.3.0 requires at least version 1.2 of container-interop, and also requires psr/container 1.0 to explicitly signal that it is a PSR-11 provider, and to allow removal of the container-interop dependency later. Version 4.0 will require only psr/container, and will update the various factory interfaces and exception implementations to typehint against the PSR-11 interfaces, which will require changes to any implementations you have. In the meantime, you can duck-type the following factory types: Zend\\ServiceManager\\Factory\\FactoryInterface : use a callable with the following signature: php function ( \\Psr\\Container\\ContainerInterface $container, string $requestedName, array $options = null ) Zend\\ServiceManager\\Factory\\DelegatorFactoryInterface : use a callable with the following signature: php function ( \\Psr\\Container\\ContainerInterface $container, string $name, callable $callback, array $options = null ) Zend\\ServiceManager\\Initializer\\InitializerInterface : use a callable with the following signature: php function ( \\Psr\\Container\\ContainerInterface $container, $instance ) Abstract factories can not be duck typed, due to the additional canCreate() method. You can also leave your factories as-is for now, and update them once zend-servicemanager v4.0 is released, at which time we will be providing tooling to help migrate your factories to PSR-11.","title":"PSR-11 Support"},{"location":"quick-start/","text":"Quick Start The Service Manager is a modern, fast, and easy-to-use implementation of the Service Locator design pattern . The implementation implements the Container Interop interfaces, providing interoperability with other implementations. The following is a \"quick start\" tutorial intended to get you up and running with the most common features of the Service manager. 1. Install Zend Service Manager If you haven't already, install Composer . Once you have, you can install the service manager: $ composer require zendframework/zend-servicemanager 2. Configuring a service manager You can now create and configure a service manager. The service manager constructor accepts a simple array: use Zend\\ServiceManager\\ServiceManager; use Zend\\ServiceManager\\Factory\\InvokableFactory; use stdClass; $serviceManager = new ServiceManager([ 'factories' => [ stdClass::class => InvokableFactory::class, ], ]); The service manager accepts a variety of keys; refer to the Configuring service manager section for full details. 3. Retrieving objects Finally, you can retrieve instances using the get() method: $object = $serviceManager->get(stdClass::class); By default, all objects created through the service manager are shared. This means that calling the get() method twice will return the exact same object: $object1 = $serviceManager->get(stdClass::class); $object2 = $serviceManager->get(stdClass::class); var_dump($object1 === $object2); // prints \"true\" You can use the build() method to retrieve discrete instances for a service: $object1 = $serviceManager->build(stdClass::class); $object2 = $serviceManager->build(stdClass::class); var_dump($object1 === $object2); // prints \"false\"","title":"Quick Start"},{"location":"quick-start/#quick-start","text":"The Service Manager is a modern, fast, and easy-to-use implementation of the Service Locator design pattern . The implementation implements the Container Interop interfaces, providing interoperability with other implementations. The following is a \"quick start\" tutorial intended to get you up and running with the most common features of the Service manager.","title":"Quick Start"},{"location":"quick-start/#1-install-zend-service-manager","text":"If you haven't already, install Composer . Once you have, you can install the service manager: $ composer require zendframework/zend-servicemanager","title":"1. Install Zend Service Manager"},{"location":"quick-start/#2-configuring-a-service-manager","text":"You can now create and configure a service manager. The service manager constructor accepts a simple array: use Zend\\ServiceManager\\ServiceManager; use Zend\\ServiceManager\\Factory\\InvokableFactory; use stdClass; $serviceManager = new ServiceManager([ 'factories' => [ stdClass::class => InvokableFactory::class, ], ]); The service manager accepts a variety of keys; refer to the Configuring service manager section for full details.","title":"2. Configuring a service manager"},{"location":"quick-start/#3-retrieving-objects","text":"Finally, you can retrieve instances using the get() method: $object = $serviceManager->get(stdClass::class); By default, all objects created through the service manager are shared. This means that calling the get() method twice will return the exact same object: $object1 = $serviceManager->get(stdClass::class); $object2 = $serviceManager->get(stdClass::class); var_dump($object1 === $object2); // prints \"true\" You can use the build() method to retrieve discrete instances for a service: $object1 = $serviceManager->build(stdClass::class); $object2 = $serviceManager->build(stdClass::class); var_dump($object1 === $object2); // prints \"false\"","title":"3. Retrieving objects"},{"location":"reflection-abstract-factory/","text":"Reflection Factory Since 3.2.0. Writing a factory class for each and every service that has dependencies can be tedious, particularly in early development as you are still sorting out dependencies. zend-servicemanager ships with Zend\\ServiceManager\\AbstractFactory\\ReflectionBasedAbstractFactory , which provides a reflection-based approach to instantiation, resolving constructor dependencies to the relevant services. The factory may be used as either an abstract factory, or mapped to specific service names as a factory: use Zend\\ServiceManager\\AbstractFactory\\ReflectionBasedAbstractFactory; return [ /* ... */ 'service_manager' => [ 'abstract_factories' => [ ReflectionBasedAbstractFactory::class, ], 'factories' => [ 'MyModule\\Model\\FooModel' => ReflectionBasedAbstractFactory::class, ], ], /* ... */ ]; Mapping services to the factory is more explicit and performant. The factory operates with the following constraints/features: A parameter named $config typehinted as an array will receive the application \"config\" service (i.e., the merged configuration). Parameters typehinted against array, but not named $config , will be injected with an empty array. Scalar parameters will result in the factory raising an exception, unless a default value is present; if it is, that value will be used. If a service cannot be found for a given typehint, the factory will raise an exception detailing this. $options passed to the factory are ignored in all cases, as we cannot make assumptions about which argument(s) they might replace. Once your dependencies have stabilized, we recommend writing a dedicated factory, as reflection can introduce performance overhead; you may use the generate-factory-for-class console tool to do so. Handling well-known services Some services provided by Zend Framework components do not have entries based on their class name (for historical reasons). As examples: Zend\\Console\\Adapter\\AdapterInterface maps to the service name ConsoleAdapter , Zend\\Filter\\FilterPluginManager maps to the service name FilterManager , Zend\\Hydrator\\HydratorPluginManager maps to the service name HydratorManager , Zend\\InputFilter\\InputFilterPluginManager maps to the service name InputFilterManager , Zend\\Log\\FilterPluginManager maps to the service name LogFilterManager , Zend\\Log\\FormatterPluginManager maps to the service name LogFormatterManager , Zend\\Log\\ProcessorPluginManager maps to the service name LogProcessorManager , Zend\\Log\\WriterPluginManager maps to the service name LogWriterManager , Zend\\Serializer\\AdapterPluginManager maps to the service name SerializerAdapterManager , Zend\\Validator\\ValidatorPluginManager maps to the service name ValidatorManager , To allow the ReflectionBasedAbstractFactory to find these, you have two options. The first is to pass an array of mappings via the constructor: $reflectionFactory = new ReflectionBasedAbstractFactory([ \\Zend\\Console\\Adapter\\AdapterInterface::class => 'ConsoleAdapter', \\Zend\\Filter\\FilterPluginManager::class => 'FilterManager', \\Zend\\Hydrator\\HydratorPluginManager::class => 'HydratorManager', \\Zend\\InputFilter\\InputFilterPluginManager::class => 'InputFilterManager', \\Zend\\Log\\FilterPluginManager::class => 'LogFilterManager', \\Zend\\Log\\FormatterPluginManager::class => 'LogFormatterManager', \\Zend\\Log\\ProcessorPluginManager::class => 'LogProcessorManager', \\Zend\\Log\\WriterPluginManager::class => 'LogWriterManager', \\Zend\\Serializer\\AdapterPluginManager::class => 'SerializerAdapterManager', \\Zend\\Validator\\ValidatorPluginManager::class => 'ValidatorManager', ]); This can be done either in your configuration file (which could be problematic when considering serialization for caching), or during an early phase of application bootstrapping. For instance, with zend-mvc, this might be in your Application module's bootstrap listener: namespace Application use Zend\\ServiceManager\\AbstractFactory\\ReflectionBasedAbstractFactory; class Module { public function onBootstrap($e) { $application = $e->getApplication(); $container = $e->getServiceManager(); $container->addAbstractFactory(new ReflectionBasedAbstractFactory([ /* ... */ ])); } } For Expressive, it could be part of your config/container.php definition: $container = new ServiceManager(); (new Config($config['dependencies']))->configureServiceManager($container); // Add the following: $container->addAbstractFactory(new ReflectionBasedAbstractFactory([ /* ... */ ])); The second approach is to extend the class, and define the map in the $aliases property: namespace Application; use Zend\\ServiceManager\\AbstractFactory\\ReflectionBasedAbstractFactory; class ReflectionAbstractFactory extends ReflectionBasedAbstractFactory { protected $aliases = [ \\Zend\\Console\\Adapter\\AdapterInterface::class => 'ConsoleAdapter', \\Zend\\Filter\\FilterPluginManager::class => 'FilterManager', \\Zend\\Hydrator\\HydratorPluginManager::class => 'HydratorManager', \\Zend\\InputFilter\\InputFilterPluginManager::class => 'InputFilterManager', \\Zend\\Log\\FilterPluginManager::class => 'LogFilterManager', \\Zend\\Log\\FormatterPluginManager::class => 'LogFormatterManager', \\Zend\\Log\\ProcessorPluginManager::class => 'LogProcessorManager', \\Zend\\Log\\WriterPluginManager::class => 'LogWriterManager', \\Zend\\Serializer\\AdapterPluginManager::class => 'SerializerAdapterManager', \\Zend\\Validator\\ValidatorPluginManager::class => 'ValidatorManager', ]; } You could then register it via class name in your service configuration. Alternatives You may also use the Config Abstract Factory , which gives slightly more flexibility in terms of mapping dependencies: If you wanted to map to a specific implementation, choose the ConfigAbstractFactory . If you need to map to a service that will return a scalar or array (e.g., a subset of the 'config' service), choose the ConfigAbstractFactory . If you need a faster factory for production, choose the ConfigAbstractFactory or create a custom factory. References This feature was inspired by a blog post by Alexandre Lemaire .","title":"Reflection-based Abstract Factory"},{"location":"reflection-abstract-factory/#reflection-factory","text":"Since 3.2.0. Writing a factory class for each and every service that has dependencies can be tedious, particularly in early development as you are still sorting out dependencies. zend-servicemanager ships with Zend\\ServiceManager\\AbstractFactory\\ReflectionBasedAbstractFactory , which provides a reflection-based approach to instantiation, resolving constructor dependencies to the relevant services. The factory may be used as either an abstract factory, or mapped to specific service names as a factory: use Zend\\ServiceManager\\AbstractFactory\\ReflectionBasedAbstractFactory; return [ /* ... */ 'service_manager' => [ 'abstract_factories' => [ ReflectionBasedAbstractFactory::class, ], 'factories' => [ 'MyModule\\Model\\FooModel' => ReflectionBasedAbstractFactory::class, ], ], /* ... */ ]; Mapping services to the factory is more explicit and performant. The factory operates with the following constraints/features: A parameter named $config typehinted as an array will receive the application \"config\" service (i.e., the merged configuration). Parameters typehinted against array, but not named $config , will be injected with an empty array. Scalar parameters will result in the factory raising an exception, unless a default value is present; if it is, that value will be used. If a service cannot be found for a given typehint, the factory will raise an exception detailing this. $options passed to the factory are ignored in all cases, as we cannot make assumptions about which argument(s) they might replace. Once your dependencies have stabilized, we recommend writing a dedicated factory, as reflection can introduce performance overhead; you may use the generate-factory-for-class console tool to do so.","title":"Reflection Factory"},{"location":"reflection-abstract-factory/#handling-well-known-services","text":"Some services provided by Zend Framework components do not have entries based on their class name (for historical reasons). As examples: Zend\\Console\\Adapter\\AdapterInterface maps to the service name ConsoleAdapter , Zend\\Filter\\FilterPluginManager maps to the service name FilterManager , Zend\\Hydrator\\HydratorPluginManager maps to the service name HydratorManager , Zend\\InputFilter\\InputFilterPluginManager maps to the service name InputFilterManager , Zend\\Log\\FilterPluginManager maps to the service name LogFilterManager , Zend\\Log\\FormatterPluginManager maps to the service name LogFormatterManager , Zend\\Log\\ProcessorPluginManager maps to the service name LogProcessorManager , Zend\\Log\\WriterPluginManager maps to the service name LogWriterManager , Zend\\Serializer\\AdapterPluginManager maps to the service name SerializerAdapterManager , Zend\\Validator\\ValidatorPluginManager maps to the service name ValidatorManager , To allow the ReflectionBasedAbstractFactory to find these, you have two options. The first is to pass an array of mappings via the constructor: $reflectionFactory = new ReflectionBasedAbstractFactory([ \\Zend\\Console\\Adapter\\AdapterInterface::class => 'ConsoleAdapter', \\Zend\\Filter\\FilterPluginManager::class => 'FilterManager', \\Zend\\Hydrator\\HydratorPluginManager::class => 'HydratorManager', \\Zend\\InputFilter\\InputFilterPluginManager::class => 'InputFilterManager', \\Zend\\Log\\FilterPluginManager::class => 'LogFilterManager', \\Zend\\Log\\FormatterPluginManager::class => 'LogFormatterManager', \\Zend\\Log\\ProcessorPluginManager::class => 'LogProcessorManager', \\Zend\\Log\\WriterPluginManager::class => 'LogWriterManager', \\Zend\\Serializer\\AdapterPluginManager::class => 'SerializerAdapterManager', \\Zend\\Validator\\ValidatorPluginManager::class => 'ValidatorManager', ]); This can be done either in your configuration file (which could be problematic when considering serialization for caching), or during an early phase of application bootstrapping. For instance, with zend-mvc, this might be in your Application module's bootstrap listener: namespace Application use Zend\\ServiceManager\\AbstractFactory\\ReflectionBasedAbstractFactory; class Module { public function onBootstrap($e) { $application = $e->getApplication(); $container = $e->getServiceManager(); $container->addAbstractFactory(new ReflectionBasedAbstractFactory([ /* ... */ ])); } } For Expressive, it could be part of your config/container.php definition: $container = new ServiceManager(); (new Config($config['dependencies']))->configureServiceManager($container); // Add the following: $container->addAbstractFactory(new ReflectionBasedAbstractFactory([ /* ... */ ])); The second approach is to extend the class, and define the map in the $aliases property: namespace Application; use Zend\\ServiceManager\\AbstractFactory\\ReflectionBasedAbstractFactory; class ReflectionAbstractFactory extends ReflectionBasedAbstractFactory { protected $aliases = [ \\Zend\\Console\\Adapter\\AdapterInterface::class => 'ConsoleAdapter', \\Zend\\Filter\\FilterPluginManager::class => 'FilterManager', \\Zend\\Hydrator\\HydratorPluginManager::class => 'HydratorManager', \\Zend\\InputFilter\\InputFilterPluginManager::class => 'InputFilterManager', \\Zend\\Log\\FilterPluginManager::class => 'LogFilterManager', \\Zend\\Log\\FormatterPluginManager::class => 'LogFormatterManager', \\Zend\\Log\\ProcessorPluginManager::class => 'LogProcessorManager', \\Zend\\Log\\WriterPluginManager::class => 'LogWriterManager', \\Zend\\Serializer\\AdapterPluginManager::class => 'SerializerAdapterManager', \\Zend\\Validator\\ValidatorPluginManager::class => 'ValidatorManager', ]; } You could then register it via class name in your service configuration.","title":"Handling well-known services"},{"location":"reflection-abstract-factory/#alternatives","text":"You may also use the Config Abstract Factory , which gives slightly more flexibility in terms of mapping dependencies: If you wanted to map to a specific implementation, choose the ConfigAbstractFactory . If you need to map to a service that will return a scalar or array (e.g., a subset of the 'config' service), choose the ConfigAbstractFactory . If you need a faster factory for production, choose the ConfigAbstractFactory or create a custom factory.","title":"Alternatives"},{"location":"reflection-abstract-factory/#references","text":"This feature was inspired by a blog post by Alexandre Lemaire .","title":"References"},{"location":"cookbook/factories-vs-abstract-factories/","text":"When To Use Factories vs Abstract Factories Starting with version 3, Zend\\ServiceManager\\Factory\\AbstractFactoryInterface extends Zend\\ServiceManager\\Factory\\FactoryInterface , meaning they may be used as either an abstract factory, or mapped to a specific service name as its factory. As an example: return [ 'factories' => [ SomeService::class => AnAbstractFactory::class, ], ]; Why would you choose one approach over the other? Comparisons Approach Pros Cons Abstract factory One-time setup Performance; discovery of code responsible for creating instance Factory Performance; explicit mapping to factory responsible Additional (duplicate) setup Essentially, it comes down to convenience versus explicitness and/or performance . Convenience Writing a factory per service is time consuming, and, particularly in early stages of an application, can distract from the actual business of writing the classes and implementations; in addition, since requirements are often changing regularly, this boiler-plate code can be a nuisance. In such situations, one or more abstract factories \u2014 such as the ConfigAbstractFactory , the ReflectionBasedAbstractFactory , or the zend-mvc LazyControllerAbstractFactory \u2014 that can handle the bulk of your needs are often worthwhile, saving you time and effort as you code. Explicitness The drawback of abstract factories is that lookups by the service manager take longer, and increase based on the number of abstract factories in the system. The service manager is optimized to locate factories , as it can do an immediate hash table lookup; abstract factories involve: Looping through each abstract factory invoking its method for service location if the service is located, using the factory This means, internally: a hash table lookup (for the abstract factory) invocation of 1:N methods for discovery which may contain additional lookups and/or retrievals in the container invocation of a factory method (assuming succesful lookup) As such, having an explicit map can aid performance dramatically. Additionally, having an explicit map can aid in understanding what class is responsible for initializing a given service. Without an explicit map, you need to identify all possible abstract factories, and determine which one is capable of handling the specific service; in some cases, multiple factories might be able to, which means you additionally need to know the order in which they will be queried. The primary drawback is that you also end up with potentially duplicate information in your configuration: Multiple services mapped to the same factory. In cases such as the ConfigAbstractFactory , additional configuration detailing how to create the service. Tradeoffs What it comes down to is which development aspects your organization or project favor. Hopefully the above arguments detail what tradeoffs occur, so you may make an appropriate choice. Tooling Starting with 3.2.0, we began offering a variety of console tools to assist you in generating both dependency configuration and factories. Use these to help your code evolve. An expected workflow in your application development evolution is: Usage of the ReflectionBasedAbstractFactory as a \"catch-all\", so that you do not need to do any factory/dependency configuration immediately. Usage of the ConfigAbstractFactory , mapped to services, once dependencies have settled, to disambiguate dependencies, or to list custom services returning scalar or array values. Finally, usage of the generate-factory-for-class vendor binary to generate actual factory classes for your production-ready code, providing the best performance.","title":"Factories vs Abstract Factories"},{"location":"cookbook/factories-vs-abstract-factories/#when-to-use-factories-vs-abstract-factories","text":"Starting with version 3, Zend\\ServiceManager\\Factory\\AbstractFactoryInterface extends Zend\\ServiceManager\\Factory\\FactoryInterface , meaning they may be used as either an abstract factory, or mapped to a specific service name as its factory. As an example: return [ 'factories' => [ SomeService::class => AnAbstractFactory::class, ], ]; Why would you choose one approach over the other?","title":"When To Use Factories vs Abstract Factories"},{"location":"cookbook/factories-vs-abstract-factories/#comparisons","text":"Approach Pros Cons Abstract factory One-time setup Performance; discovery of code responsible for creating instance Factory Performance; explicit mapping to factory responsible Additional (duplicate) setup Essentially, it comes down to convenience versus explicitness and/or performance .","title":"Comparisons"},{"location":"cookbook/factories-vs-abstract-factories/#convenience","text":"Writing a factory per service is time consuming, and, particularly in early stages of an application, can distract from the actual business of writing the classes and implementations; in addition, since requirements are often changing regularly, this boiler-plate code can be a nuisance. In such situations, one or more abstract factories \u2014 such as the ConfigAbstractFactory , the ReflectionBasedAbstractFactory , or the zend-mvc LazyControllerAbstractFactory \u2014 that can handle the bulk of your needs are often worthwhile, saving you time and effort as you code.","title":"Convenience"},{"location":"cookbook/factories-vs-abstract-factories/#explicitness","text":"The drawback of abstract factories is that lookups by the service manager take longer, and increase based on the number of abstract factories in the system. The service manager is optimized to locate factories , as it can do an immediate hash table lookup; abstract factories involve: Looping through each abstract factory invoking its method for service location if the service is located, using the factory This means, internally: a hash table lookup (for the abstract factory) invocation of 1:N methods for discovery which may contain additional lookups and/or retrievals in the container invocation of a factory method (assuming succesful lookup) As such, having an explicit map can aid performance dramatically. Additionally, having an explicit map can aid in understanding what class is responsible for initializing a given service. Without an explicit map, you need to identify all possible abstract factories, and determine which one is capable of handling the specific service; in some cases, multiple factories might be able to, which means you additionally need to know the order in which they will be queried. The primary drawback is that you also end up with potentially duplicate information in your configuration: Multiple services mapped to the same factory. In cases such as the ConfigAbstractFactory , additional configuration detailing how to create the service.","title":"Explicitness"},{"location":"cookbook/factories-vs-abstract-factories/#tradeoffs","text":"What it comes down to is which development aspects your organization or project favor. Hopefully the above arguments detail what tradeoffs occur, so you may make an appropriate choice.","title":"Tradeoffs"},{"location":"cookbook/factories-vs-abstract-factories/#tooling","text":"Starting with 3.2.0, we began offering a variety of console tools to assist you in generating both dependency configuration and factories. Use these to help your code evolve. An expected workflow in your application development evolution is: Usage of the ReflectionBasedAbstractFactory as a \"catch-all\", so that you do not need to do any factory/dependency configuration immediately. Usage of the ConfigAbstractFactory , mapped to services, once dependencies have settled, to disambiguate dependencies, or to list custom services returning scalar or array values. Finally, usage of the generate-factory-for-class vendor binary to generate actual factory classes for your production-ready code, providing the best performance.","title":"Tooling"}]}